import * as java from './java';
export interface KCallback<A> {
    (a: A): void;
}
export declare class KConfig {
    static CAS_MAX_TRY: number;
    static CALLBACK_HISTORY: number;
    static LONG_SIZE: number;
    static PREFIX_SIZE: number;
    static BEGINNING_OF_TIME: number;
    static END_OF_TIME: number;
    static NULL_LONG: number;
    static KEY_PREFIX_MASK: number;
    static KEY_SEP: string;
    static ELEM_SEP: string;
    static VAL_SEP: string;
    static CHUNK_ELEM_SEP: string;
    static CHUNK_VAL_SEP: string;
    static CACHE_INIT_SIZE: number;
    static CACHE_LOAD_FACTOR: number;
}
export declare class KContentKey {
    static NULL_KEY: Float64Array;
    static GLOBAL_UNIVERSE_KEY: Float64Array;
    universe: number;
    time: number;
    obj: number;
    static toString(keys: Float64Array, keyIndex: number): string;
    constructor(p_universeID: number, p_timeID: number, p_objID: number);
    static createObject(p_universeID: number, p_quantaID: number, p_objectID: number): KContentKey;
    static createGlobalUniverseTree(): KContentKey;
    static createRootUniverseTree(): KContentKey;
    static createLastPrefix(): KContentKey;
    static create(payload: string): KContentKey;
    equals(param: any): boolean;
}
export interface KListener {
    universe(): number;
    listenObjects(): Float64Array;
    listen(obj: KObject): void;
    destroy(): void;
    then(updatedObjects: KCallback<any>): void;
}
export interface KModel<A extends KUniverse<any, any>> {
    key(): number;
    newUniverse(): A;
    universe(key: number): A;
    manager(): memory.manager.KDataManager;
    metaModel(): meta.KMetaModel;
    defer(): defer.KDefer;
    setOperation(metaOperation: meta.KMetaOperation, operation: KOperation<any, any>): void;
    setOperationByName(metaClassName: string, metaOperationName: string, operation: KOperation<any, any>): void;
    save(callback: KCallback<any>): void;
    connect(callback: KCallback<any>): void;
    disconnect(callback: KCallback<any>): void;
    lookup(universe: number, time: number, uuid: number, callback: KCallback<KObject>): void;
    lookupAllObjects(universe: number, time: number, uuids: Float64Array, callback: KCallback<KObject[]>): void;
    lookupAllTimes(universe: number, times: Float64Array, uuid: number, callback: KCallback<KObject[]>): void;
    createPreparedLookup(size: number): KPreparedLookup;
    lookupPrepared(prepared: KPreparedLookup, callback: KCallback<KObject[]>): void;
    createByName(metaClassName: string, universe: number, time: number): KObject;
    create(clazz: meta.KMetaClass, universe: number, time: number): KObject;
    createListener(universe: number): KListener;
    createModelContext(): KModelContext;
    createTraversal(startingElements: KObject[]): traversal.KTraversal;
    createReusableTraversal(): traversal.KTraversal;
    indexByName(universe: number, time: number, indexName: string, callback: KCallback<KObjectIndex>): void;
    find(metaClass: meta.KMetaClass, universe: number, time: number, attributes: string, callback: KCallback<KObject>): void;
    findByName(indexName: string, universe: number, time: number, attributes: string, callback: KCallback<KObject>): void;
    findAll(metaClass: meta.KMetaClass, universe: number, time: number, callback: KCallback<KObject[]>): void;
    findAllByName(indexName: string, universe: number, time: number, callback: KCallback<KObject[]>): void;
}
export interface KModelContext {
    set(originTime: number, maxTime: number, originUniverse: number, maxUniverse: number): void;
    originTime(): number;
    originUniverse(): number;
    maxTime(): number;
    maxUniverse(): number;
    listen(callback: KCallback<Float64Array>): void;
    model(): KModel<any>;
}
export interface KObject {
    universe(): number;
    now(): number;
    uuid(): number;
    metaClass(): meta.KMetaClass;
    visitAttributes(visitor: traversal.visitor.KModelAttributeVisitor): void;
    visit(visitor: traversal.visitor.KModelVisitor, callback: KCallback<any>): void;
    traversal(): traversal.KTraversal;
    jump(time: number, callback: KCallback<KObject>): void;
    select(query: string, callback: KCallback<any[]>): void;
    detach(cb: KCallback<any>): void;
    addByName(metaRelationName: string, objToAdd: KObject): void;
    add(metaRelation: meta.KMetaRelation, objToAdd: KObject): void;
    removeByName(metaRelationName: string, objToRemove: KObject): void;
    remove(metaRelation: meta.KMetaRelation, objToRemove: KObject): void;
    addAllByName(metaRelationName: string, objsToAdd: KObject[]): void;
    addAll(metaRelation: meta.KMetaRelation, objsToAdd: KObject[]): void;
    removeAllByName(metaRelationName: string, callback: KCallback<any>): void;
    removeAll(metaRelation: meta.KMetaRelation, callback: KCallback<any>): void;
    getRelationByName(metaRelationName: string, callback: KCallback<KObject[]>): void;
    getRelation(metaRelation: meta.KMetaRelation, callback: KCallback<KObject[]>): void;
    getRelationValuesByName(metaRelationName: string): Float64Array;
    getRelationValues(metaRelation: meta.KMetaRelation): Float64Array;
    get(metaAttribute: meta.KMetaAttribute): any;
    getByName(metaAttributeName: string): any;
    set(metaAttribute: meta.KMetaAttribute, payload: any): void;
    setByName(metaAttributeName: string, payload: any): void;
    enforceTimepoint(): void;
    timeDephasing(): number;
    allTimes(cb: KCallback<Float64Array>): void;
    timesBefore(endOfSearch: number, cb: KCallback<Float64Array>): void;
    timesAfter(beginningOfSearch: number, cb: KCallback<Float64Array>): void;
    timesBetween(beginningOfSearch: number, endOfSearch: number, cb: KCallback<Float64Array>): void;
    toJSON(): string;
    equals(other: any): boolean;
    referencesWith(o: KObject): meta.KMetaRelation[];
    invokeOperation(operation: meta.KMetaOperation, params: any[], strategy: operation.KOperationStrategy, cb: KCallback<any>): void;
    invokeOperationByName(operationName: string, params: any[], strategy: operation.KOperationStrategy, cb: KCallback<any>): void;
    manager(): memory.manager.KDataManager;
    compare(target: KObject): meta.KMeta[];
}
export interface KObjectIndex extends KObject {
    getIndex(key: string): number;
    setIndex(key: string, value: number): void;
    values(): Float64Array;
}
export interface KObjectInfer extends KObject {
    genericTrain(dependencies: KObject[], expectedOutputs: any[], callback: KCallback<any>): void;
    genericTrainAll(trainingSet: KObject[][], expectedResultSet: any[][], callback: KCallback<any>): void;
    genericInfer(features: KObject[], callback: KCallback<any[]>): void;
    genericInferAll(features: KObject[][], callback: KCallback<any[][]>): void;
    resetLearning(): void;
}
export interface KOperation<SourceObject extends KObject, ResultType> {
    (source: SourceObject, params: any[], result: KCallback<ResultType>): void;
}
export interface KPreparedLookup {
    addLookupOperation(universe: number, time: number, uuid: number): void;
    flatLookup(): Float64Array;
}
export interface KType {
    name(): string;
    id(): number;
}
export interface KUniverse<A extends KView, B extends KUniverse<any, any>> {
    key(): number;
    time(timePoint: number): A;
    diverge(): B;
    equals(other: any): boolean;
    lookupAllTimes(uuid: number, times: Float64Array, cb: KCallback<KObject[]>): void;
    createListener(): KListener;
}
export interface KView {
    createByName(metaClassName: string): KObject;
    create(clazz: meta.KMetaClass): KObject;
    select(query: string, cb: KCallback<any[]>): void;
    lookup(key: number, cb: KCallback<KObject>): void;
    lookupAll(keys: Float64Array, cb: KCallback<KObject[]>): void;
    universe(): number;
    now(): number;
    model(): KModel<any>;
    json(): format.KModelFormat;
    equals(other: any): boolean;
}
export declare namespace abs {
    class AbstractDataType implements KType {
        private _name;
        private _id;
        constructor(p_name: string, p_id: number);
        name(): string;
        id(): number;
    }
    class AbstractKModel<A extends KUniverse<any, any>> implements KModel<A> {
        _manager: memory.manager.internal.KInternalDataManager;
        private _key;
        constructor(p_manager: memory.manager.internal.KInternalDataManager);
        metaModel(): meta.KMetaModel;
        connect(cb: KCallback<any>): void;
        disconnect(cb: KCallback<any>): void;
        manager(): memory.manager.KDataManager;
        newUniverse(): A;
        internalCreateUniverse(universe: number): A;
        internalCreateObject(universe: number, time: number, uuid: number, clazz: meta.KMetaClass, previousUniverse: number, previousTime: number): KObject;
        createProxy(universe: number, time: number, uuid: number, clazz: meta.KMetaClass, previousUniverse: number, previousTime: number): KObject;
        universe(key: number): A;
        save(callback: KCallback<any>): void;
        setOperation(metaOperation: meta.KMetaOperation, operation: KOperation<any, any>): void;
        setOperationByName(metaClassName: string, metaOperationName: string, operation: KOperation<any, any>): void;
        defer(): defer.KDefer;
        key(): number;
        create(clazz: meta.KMetaClass, universe: number, time: number): KObject;
        createByName(metaClassName: string, universe: number, time: number): KObject;
        lookup(p_universe: number, p_time: number, p_uuid: number, callback: KCallback<KObject>): void;
        lookupAllObjects(p_universe: number, p_time: number, p_uuids: Float64Array, callback: KCallback<KObject[]>): void;
        lookupAllTimes(p_universe: number, p_times: Float64Array, p_uuids: number, callback: KCallback<KObject[]>): void;
        createPreparedLookup(p_size: number): KPreparedLookup;
        lookupPrepared(p_prepared: KPreparedLookup, p_callback: KCallback<KObject[]>): void;
        createListener(universe: number): KListener;
        createModelContext(): KModelContext;
        createTraversal(startingElements: KObject[]): traversal.KTraversal;
        createReusableTraversal(): traversal.KTraversal;
        find(metaClass: meta.KMetaClass, universe: number, time: number, attributes: string, callback: KCallback<KObject>): void;
        findByName(indexName: string, universe: number, time: number, attributes: string, callback: KCallback<KObject>): void;
        private buildParams(p_paramString);
        indexByName(universe: number, time: number, indexName: string, callback: KCallback<KObjectIndex>): void;
        findAll(metaClass: meta.KMetaClass, universe: number, time: number, callback: KCallback<KObject[]>): void;
        findAllByName(indexName: string, universe: number, time: number, callback: KCallback<KObject[]>): void;
    }
    class AbstractKModelContext implements KModelContext {
        static ORIGIN_TIME: number;
        static MAX_TIME: number;
        static ORIGIN_UNIVERSE: number;
        static MAX_UNIVERSE: number;
        static NB_ELEM: number;
        private _callbacks;
        private _bounds;
        private _origin;
        constructor(p_origin: KModel<any>);
        set(p_originTime: number, p_maxTime: number, p_originUniverse: number, p_maxUniverse: number): void;
        originTime(): number;
        originUniverse(): number;
        maxTime(): number;
        maxUniverse(): number;
        listen(new_callback: KCallback<Float64Array>): void;
        model(): KModel<any>;
    }
    class AbstractKObject implements KObject {
        _uuid: number;
        _time: number;
        _universe: number;
        _metaClass: meta.KMetaClass;
        _manager: memory.manager.internal.KInternalDataManager;
        private static OUT_OF_CACHE_MSG;
        _previousResolveds: java.util.concurrent.atomic.AtomicReference<Float64Array>;
        static UNIVERSE_PREVIOUS_INDEX: number;
        static TIME_PREVIOUS_INDEX: number;
        constructor(p_universe: number, p_time: number, p_uuid: number, p_metaClass: meta.KMetaClass, p_manager: memory.manager.internal.KInternalDataManager, p_actualUniverse: number, p_actualTime: number);
        previousResolved(): java.util.concurrent.atomic.AtomicReference<Float64Array>;
        timeDephasing(): number;
        uuid(): number;
        metaClass(): meta.KMetaClass;
        now(): number;
        universe(): number;
        detach(callback: KCallback<any>): void;
        select(query: string, cb: KCallback<any[]>): void;
        get(p_attribute: meta.KMetaAttribute): any;
        getByName(attributeName: string): any;
        set(p_attribute: meta.KMetaAttribute, payload: any): void;
        setByName(attributeName: string, payload: any): void;
        addByName(relationName: string, objToAdd: KObject): void;
        add(p_metaReference: meta.KMetaRelation, objToAdd: KObject): void;
        private internal_add(p_metaReference, p_param, p_setOpposite);
        enforceTimepoint(): void;
        removeByName(relationName: string, objToAdd: KObject): void;
        remove(p_metaReference: meta.KMetaRelation, objToRemove: KObject): void;
        private internal_remove(p_metaReference, objToRemove, p_setOpposite);
        addAllByName(p_metaRelationName: string, objsToAdd: KObject[]): void;
        addAll(p_metaRelation: meta.KMetaRelation, objsToAdd: KObject[]): void;
        removeAllByName(p_metaRelationName: string, callback: KCallback<any>): void;
        removeAll(p_metaRelation: meta.KMetaRelation, callback: KCallback<any>): void;
        private internal_removeAll(p_metaRelation, callback);
        size(p_metaReference: meta.KMetaRelation): number;
        getRelationByName(p_metaRelationName: string, cb: KCallback<KObject[]>): void;
        getRelation(p_metaReference: meta.KMetaRelation, cb: KCallback<KObject[]>): void;
        private internal_getRelation(p_transposedRelation, cb);
        getRelationValuesByName(p_refName: string): Float64Array;
        getRelationValues(metaRelation: meta.KMetaRelation): Float64Array;
        private internal_getRefValues(transposedReference);
        visitAttributes(visitor: traversal.visitor.KModelAttributeVisitor): void;
        visit(p_visitor: traversal.visitor.KModelVisitor, cb: KCallback<any>): void;
        private internal_visit(visitor, end, visited, traversed);
        toJSON(): string;
        toString(): string;
        equals(obj: any): boolean;
        hashCode(): number;
        jump(p_time: number, p_callback: KCallback<KObject>): void;
        internal_transpose_ref(p: meta.KMetaRelation): meta.KMetaRelation;
        internal_transpose_att(p: meta.KMetaAttribute): meta.KMetaAttribute;
        internal_transpose_op(p: meta.KMetaOperation): meta.KMetaOperation;
        traversal(): traversal.KTraversal;
        referencesWith(o: KObject): meta.KMetaRelation[];
        invokeOperation(p_operation: meta.KMetaOperation, p_params: any[], strategy: operation.KOperationStrategy, cb: KCallback<any>): void;
        invokeOperationByName(operationName: string, p_params: any[], strategy: operation.KOperationStrategy, cb: KCallback<any>): void;
        manager(): memory.manager.KDataManager;
        private internal_times(start, end, cb);
        allTimes(cb: KCallback<Float64Array>): void;
        timesBefore(endOfSearch: number, cb: KCallback<Float64Array>): void;
        timesAfter(beginningOfSearch: number, cb: KCallback<Float64Array>): void;
        timesBetween(beginningOfSearch: number, endOfSearch: number, cb: KCallback<Float64Array>): void;
        compare(target: KObject): meta.KMeta[];
    }
    class AbstractKObjectIndex extends abs.AbstractKObject implements KObjectIndex {
        constructor(p_universe: number, p_time: number, p_uuid: number, p_manager: memory.manager.internal.KInternalDataManager, p_actualUniverse: number, p_actualTime: number);
        getIndex(key: string): number;
        setIndex(key: string, value: number): void;
        values(): Float64Array;
    }
    class AbstractKObjectInfer extends abs.AbstractKObject implements KObjectInfer {
        constructor(p_universe: number, p_time: number, p_uuid: number, p_metaClass: meta.KMetaClass, p_manager: memory.manager.internal.KInternalDataManager, currentUniverse: number, currentTime: number);
        genericTrain(dependencies: KObject[], expectedOutputs: any[], callback: KCallback<any>): void;
        genericTrainAll(p_dependencies: KObject[][], p_outputs: any[][], callback: KCallback<any>): void;
        genericInfer(dependencies: KObject[], callback: KCallback<any[]>): void;
        genericInferAll(p_dependencies: KObject[][], callback: KCallback<any[][]>): void;
        resetLearning(): void;
        private internalConvertOutput(output, metaOutput);
        private internalReverseOutput(inferred, metaOutput);
        private math_ceil(toCeilValue);
    }
    class AbstractKUniverse<A extends KView, B extends KUniverse<any, any>> implements KUniverse<A, B> {
        _universe: number;
        _manager: memory.manager.internal.KInternalDataManager;
        constructor(p_key: number, p_manager: memory.manager.internal.KInternalDataManager);
        key(): number;
        time(timePoint: number): A;
        internal_create(timePoint: number): A;
        equals(obj: any): boolean;
        diverge(): B;
        lookupAllTimes(uuid: number, times: Float64Array, cb: KCallback<KObject[]>): void;
        createListener(): KListener;
    }
    class AbstractKView implements KView {
        _time: number;
        _universe: number;
        _manager: memory.manager.internal.KInternalDataManager;
        constructor(p_universe: number, _time: number, p_manager: memory.manager.internal.KInternalDataManager);
        now(): number;
        universe(): number;
        model(): KModel<any>;
        select(query: string, cb: KCallback<any[]>): void;
        lookup(kid: number, cb: KCallback<KObject>): void;
        lookupAll(keys: Float64Array, cb: KCallback<KObject[]>): void;
        create(clazz: meta.KMetaClass): KObject;
        createByName(metaClassName: string): KObject;
        json(): format.KModelFormat;
        equals(obj: any): boolean;
    }
}
export declare namespace cdn {
    interface KContentDeliveryDriver {
        get(keys: Float64Array, callback: KCallback<string[]>): void;
        atomicGetIncrement(key: Float64Array, cb: KCallback<number>): void;
        put(keys: Float64Array, values: string[], error: KCallback<Error>, excludeListener: number): void;
        remove(keys: Float64Array, error: KCallback<Error>): void;
        connect(callback: KCallback<Error>): void;
        close(callback: KCallback<Error>): void;
        addUpdateListener(interceptor: cdn.KContentUpdateListener): number;
        removeUpdateListener(id: number): void;
        peers(): string[];
        sendToPeer(peer: string, message: message.KMessage, callback: KCallback<message.KMessage>): void;
    }
    interface KContentUpdateListener {
        onKeysUpdate(updatedKeys: Float64Array): void;
        onOperationCall(operationCallMessage: message.KMessage): void;
    }
    namespace impl {
        class MemoryContentDeliveryDriver implements cdn.KContentDeliveryDriver {
            private backend;
            private additionalInterceptors;
            atomicGetIncrement(key: Float64Array, cb: KCallback<number>): void;
            get(keys: Float64Array, callback: KCallback<string[]>): void;
            put(p_keys: Float64Array, p_values: string[], p_callback: KCallback<Error>, excludeListener: number): void;
            remove(p_keys: Float64Array, callback: KCallback<Error>): void;
            connect(callback: KCallback<Error>): void;
            close(callback: KCallback<Error>): void;
            private nextListenerID();
            addUpdateListener(p_interceptor: cdn.KContentUpdateListener): number;
            removeUpdateListener(id: number): void;
            peers(): string[];
            sendToPeer(peer: string, message: message.KMessage, callback: KCallback<message.KMessage>): void;
        }
    }
}
export declare namespace defer {
    interface KDefer {
        waitResult(): KCallback<any>;
        then(cb: KCallback<any[]>): void;
    }
    namespace impl {
        class Defer implements defer.KDefer {
            private _end;
            private _nbExpectedResult;
            private _nbRecResult;
            private _results;
            private _resultSize;
            waitResult(): KCallback<any>;
            then(cb: KCallback<any[]>): void;
            private informEndOrRegister(p_indexToInsert, p_result, p_end);
        }
    }
}
export declare namespace extrapolation {
    interface Extrapolation {
        extrapolate(current: KObject, attribute: meta.KMetaAttribute, dataManager: memory.manager.internal.KInternalDataManager): any;
        mutate(current: KObject, attribute: meta.KMetaAttribute, payload: any, dataManager: memory.manager.internal.KInternalDataManager): void;
    }
    namespace impl {
        class DiscreteExtrapolation implements extrapolation.Extrapolation {
            private static INSTANCE;
            static instance(): extrapolation.Extrapolation;
            extrapolate(current: KObject, attribute: meta.KMetaAttribute, dataManager: memory.manager.internal.KInternalDataManager): any;
            mutate(current: KObject, attribute: meta.KMetaAttribute, payload: any, dataManager: memory.manager.internal.KInternalDataManager): void;
            private convert(attribute, payload);
        }
        class DoublePolynomialExtrapolation implements extrapolation.Extrapolation {
            private static _TIMERR;
            private static _maxDegree;
            private static _maxTimeDegree;
            private static TIMEDEG;
            private static NUMSAMPLES;
            private static POLYDEG;
            private static STEP;
            private static TIMEWEIGHT;
            private static INSTANCE;
            extrapolate(current: KObject, attribute: meta.KMetaAttribute, dataManager: memory.manager.internal.KInternalDataManager): any;
            private getPolyWeightIndex(segment, meta, index);
            private getTime(num, segment, meta, index);
            private getLastTime(segment, meta, index);
            private extrapolateValue(segment, meta, index, time, timeOrigin);
            private maxErr(precision, degree);
            insert(time: number, value: number, timeOrigin: number, raw: memory.chunk.KObjectChunk, index: number, precision: number, metaClass: meta.KMetaClass): boolean;
            private tempError(computedWeights, times, values);
            private internal_extrapolate(t, raw, index, metaClass);
            private initial_feed(time, value, raw, index, metaClass);
            mutate(current: KObject, attribute: meta.KMetaAttribute, payload: any, dataManager: memory.manager.internal.KInternalDataManager): void;
            private getLastTimeLong(raw, kMetaClass, index);
            private castNumber(payload);
            static instance(): extrapolation.Extrapolation;
        }
        class PolynomialExtrapolation implements extrapolation.Extrapolation {
            private static _maxDegree;
            private static DEGREE;
            private static NUMSAMPLES;
            private static STEP;
            private static LASTTIME;
            private static WEIGHTS;
            private static INSTANCE;
            extrapolate(current: KObject, attribute: meta.KMetaAttribute, dataManager: memory.manager.internal.KInternalDataManager): any;
            private extrapolateValue(segment, meta, index, time, timeOrigin);
            private maxErr(precision, degree);
            insert(time: number, value: number, timeOrigin: number, raw: memory.chunk.KObjectChunk, index: number, precision: number, metaClass: meta.KMetaClass): boolean;
            private tempError(computedWeights, times, values);
            private internal_extrapolate(t, raw, index, metaClass);
            private initial_feed(time, value, raw, index, metaClass);
            mutate(current: KObject, attribute: meta.KMetaAttribute, payload: any, dataManager: memory.manager.internal.KInternalDataManager): void;
            private castNumber(payload);
            static instance(): extrapolation.Extrapolation;
        }
    }
}
export declare namespace format {
    interface KModelFormat {
        save(model: KObject, cb: KCallback<string>): void;
        load(payload: string, cb: KCallback<any>): void;
    }
    namespace json {
        class JsonFormat implements format.KModelFormat {
            static KEY_META: string;
            static KEY_UUID: string;
            private _manager;
            private _universe;
            private _time;
            private static NULL_PARAM_MSG;
            constructor(p_universe: number, p_time: number, p_manager: memory.manager.internal.KInternalDataManager);
            save(model: KObject, cb: KCallback<string>): void;
            load(payload: string, cb: KCallback<any>): void;
        }
        class JsonModelLoader {
            static load(manager: memory.manager.internal.KInternalDataManager, universe: number, time: number, payload: string, callback: KCallback<Error>): void;
            private static loadObj(p_param, manager, universe, time, p_mappedKeys, p_rootElem);
            private static transposeArr(plainRawSet, p_mappedKeys);
            private static sizeOfList(plainRawSet);
            private static getString(plainRawSet, l);
        }
        class JsonModelSerializer {
            static serialize(model: KObject, callback: KCallback<string>): void;
            static printJSON(elem: KObject, builder: java.lang.StringBuilder): void;
        }
        class JsonObjectReader {
            private readObject;
            parseObject(payload: string): void;
            get(name: string): any;
            getAsStringArray(name: string): string[];
            keys(): string[];
        }
        class JsonRaw {
            static encode(raw: memory.chunk.KObjectChunk, uuid: number, p_metaClass: meta.KMetaClass): string;
        }
        class JsonString {
            private static ESCAPE_CHAR;
            static encodeBuffer(buffer: java.lang.StringBuilder, chain: string): void;
            static encode(p_chain: string): string;
            static unescape(p_src: string): string;
        }
    }
    namespace xmi {
    }
}
export declare namespace infer {
    interface KInferAlg {
        train(trainingSet: util.maths.structure.KArray2D, expectedResultSet: util.maths.structure.KArray2D, currentInferObject: KObject, manager: memory.manager.internal.KInternalDataManager): void;
        infer(features: util.maths.structure.KArray2D, currentInferObject: KObject, manager: memory.manager.internal.KInternalDataManager): util.maths.structure.KArray2D;
    }
    class KInferAlgFactory {
        static build(name: string): infer.KInferAlg;
    }
    namespace impl {
        class BinaryPerceptronAlg implements infer.KInferAlg {
            private iterations;
            private alpha;
            private rand;
            train(trainingSet: util.maths.structure.KArray2D, expectedResultSet: util.maths.structure.KArray2D, origin: KObject, manager: memory.manager.internal.KInternalDataManager): void;
            private addUp(features, row, state);
            private sigmoid(features, row, state);
            infer(features: util.maths.structure.KArray2D, origin: KObject, manager: memory.manager.internal.KInternalDataManager): util.maths.structure.KArray2D;
        }
        class EmptyInfer implements infer.KInferAlg {
            train(trainingSet: util.maths.structure.KArray2D, expectedResultSet: util.maths.structure.KArray2D, currentInferObject: KObject, manager: memory.manager.internal.KInternalDataManager): void;
            infer(features: util.maths.structure.KArray2D, currentInferObject: KObject, manager: memory.manager.internal.KInternalDataManager): util.maths.structure.KArray2D;
        }
        class GaussianAnomalyDetectionAlg implements infer.KInferAlg {
            private _alpha;
            private static MIN;
            private static MAX;
            private static SUM;
            private static SUMSQUARE;
            private static NUMOFFIELDS;
            getProba(features: util.maths.structure.KArray2D, row: number, state: util.maths.structure.KArray1D, meta: meta.KMetaDependencies): number;
            getAvg(state: util.maths.structure.KArray1D, meta: meta.KMetaDependencies): Float64Array;
            getVariance(state: util.maths.structure.KArray1D, avg: Float64Array, meta: meta.KMetaDependencies): Float64Array;
            train(trainingSet: util.maths.structure.KArray2D, expectedResultSet: util.maths.structure.KArray2D, origin: KObject, manager: memory.manager.internal.KInternalDataManager): void;
            infer(features: util.maths.structure.KArray2D, origin: KObject, manager: memory.manager.internal.KInternalDataManager): util.maths.structure.KArray2D;
        }
        class GaussianClassifierAlg implements infer.KInferAlg {
            private static MIN;
            private static MAX;
            private static SUM;
            private static SUMSQUARE;
            private static NUMOFFIELDS;
            private getIndex(input, output, field, meta);
            private getCounter(output, meta);
            getAvg(output: number, state: util.maths.structure.KArray1D, meta: meta.KMetaDependencies): Float64Array;
            getVariance(output: number, state: util.maths.structure.KArray1D, avg: Float64Array, meta: meta.KMetaDependencies): Float64Array;
            train(trainingSet: util.maths.structure.KArray2D, expectedResultSet: util.maths.structure.KArray2D, origin: KObject, manager: memory.manager.internal.KInternalDataManager): void;
            infer(features: util.maths.structure.KArray2D, origin: KObject, manager: memory.manager.internal.KInternalDataManager): util.maths.structure.KArray2D;
            getProba(features: util.maths.structure.KArray2D, row: number, output: number, state: util.maths.structure.KArray1D, meta: meta.KMetaDependencies): number;
            getAllProba(features: Float64Array, state: util.maths.structure.impl.Array1D, meta: meta.KMetaDependencies, maxOutput: number): Float64Array;
        }
        class GaussianProfiler implements infer.KInferAlg {
            private static MIN;
            private static MAX;
            private static SUM;
            private static SUMSQUARE;
            private static NUMOFFIELDS;
            maxTimeSlots: number;
            private getIndex(input, output, field, meta);
            private getCounter(output, meta);
            getAvg(output: number, state: util.maths.structure.impl.Array1D, meta: meta.KMetaDependencies): Float64Array;
            getVariance(output: number, state: util.maths.structure.impl.Array1D, avg: Float64Array, meta: meta.KMetaDependencies): Float64Array;
            train(trainingSet: util.maths.structure.KArray2D, expectedResult: util.maths.structure.KArray2D, origin: KObject, manager: memory.manager.internal.KInternalDataManager): void;
            infer(features: util.maths.structure.KArray2D, origin: KObject, manager: memory.manager.internal.KInternalDataManager): util.maths.structure.KArray2D;
            getProba(features: Float64Array, output: number, state: util.maths.structure.impl.Array1D, meta: meta.KMetaDependencies): number;
        }
        class KMeanClusterAlg implements infer.KInferAlg {
            private k;
            private iterations;
            train(trainingSet: util.maths.structure.KArray2D, expectedResultSet: util.maths.structure.KArray2D, origin: KObject, manager: memory.manager.internal.KInternalDataManager): void;
            private classify(features, row, state);
            infer(features: util.maths.structure.KArray2D, origin: KObject, manager: memory.manager.internal.KInternalDataManager): util.maths.structure.KArray2D;
        }
        class LinearRegressionAlg implements infer.KInferAlg {
            private alpha;
            private gamma;
            private iterations;
            private static rand;
            train(trainingSet: util.maths.structure.KArray2D, expectedResultSet: util.maths.structure.KArray2D, origin: KObject, manager: memory.manager.internal.KInternalDataManager): void;
            private estimate(training, row, state);
            infer(features: util.maths.structure.KArray2D, origin: KObject, manager: memory.manager.internal.KInternalDataManager): util.maths.structure.KArray2D;
        }
        class RecommendationAlg implements infer.KInferAlg {
            train(trainingSet: util.maths.structure.KArray2D, expectedResultSet: util.maths.structure.KArray2D, currentInferObject: KObject, manager: memory.manager.internal.KInternalDataManager): void;
            infer(features: util.maths.structure.KArray2D, currentInferObject: KObject, manager: memory.manager.internal.KInternalDataManager): util.maths.structure.KArray2D;
        }
        class StatInferAlg implements infer.KInferAlg {
            private static MIN;
            private static MAX;
            private static SUM;
            private static SUMSQuare;
            private static NUMOFFIELDS;
            train(trainingSet: util.maths.structure.KArray2D, expectedResultSet: util.maths.structure.KArray2D, origin: KObject, manager: memory.manager.internal.KInternalDataManager): void;
            infer(features: util.maths.structure.KArray2D, origin: KObject, manager: memory.manager.internal.KInternalDataManager): util.maths.structure.KArray2D;
            getAvgAll(ks: memory.chunk.KObjectChunk, meta: meta.KMetaDependencies): Float64Array;
            getMinAll(ks: memory.chunk.KObjectChunk, meta: meta.KMetaDependencies): Float64Array;
            getMaxAll(ks: memory.chunk.KObjectChunk, meta: meta.KMetaDependencies): Float64Array;
            getVarianceAll(ks: memory.chunk.KObjectChunk, meta: meta.KMetaDependencies, avgs: Float64Array): Float64Array;
            getAvg(featureNum: number, ks: memory.chunk.KObjectChunk, meta: meta.KMetaDependencies): number;
            getMin(featureNum: number, ks: memory.chunk.KObjectChunk, meta: meta.KMetaDependencies): number;
            getMax(featureNum: number, ks: memory.chunk.KObjectChunk, meta: meta.KMetaDependencies): number;
            getVariance(featureNum: number, ks: memory.chunk.KObjectChunk, meta: meta.KMetaDependencies, avg: number): number;
        }
        class WinnowAlg implements infer.KInferAlg {
            private alpha;
            private beta;
            private iterations;
            private rand;
            train(trainingSet: util.maths.structure.KArray2D, expectedResultSet: util.maths.structure.KArray2D, origin: KObject, manager: memory.manager.internal.KInternalDataManager): void;
            private calculate(features, row, state);
            infer(features: util.maths.structure.KArray2D, origin: KObject, manager: memory.manager.internal.KInternalDataManager): util.maths.structure.KArray2D;
        }
    }
}
export declare namespace memory {
    interface KChunk {
        serialize(metaModel: meta.KMetaModel): string;
        init(payload: string, metaModel: meta.KMetaModel, metaClassIndex: number): void;
        counter(): number;
        inc(): number;
        dec(): number;
        free(metaModel: meta.KMetaModel): void;
        type(): number;
        space(): memory.space.KChunkSpace;
        getFlags(): number;
        setFlags(bitsToEnable: number, bitsToDisable: number): void;
        universe(): number;
        time(): number;
        obj(): number;
        dependencies(): Float64Array;
        addDependency(universe: number, time: number, uuid: number): void;
    }
    class KChunkFlags {
        static DIRTY_BIT_INDEX: number;
        static DIRTY_BIT: number;
        static REMOVED_BIT_INDEX: number;
        static REMOVED_BIT: number;
    }
    interface KOffHeapChunk extends memory.KChunk {
        memoryAddress(): number;
        setMemoryAddress(address: number): void;
    }
    namespace chunk {
        interface KIntMap<V> {
            contains(key: number): boolean;
            get(key: number): V;
            put(key: number, value: V): void;
            each(callback: memory.chunk.KIntMapCallBack<V>): void;
        }
        interface KIntMapCallBack<V> {
            (key: number, value: V): void;
        }
        interface KLongLongMap extends memory.KChunk {
            metaClassIndex(): number;
            contains(key: number): boolean;
            get(key: number): number;
            put(key: number, value: number): void;
            remove(key: number): void;
            each(callback: memory.chunk.KLongLongMapCallBack<any>): void;
            size(): number;
            clear(): void;
        }
        interface KLongLongMapCallBack<V> {
            (key: number, value: number): void;
        }
        interface KLongLongTree extends memory.chunk.KTree {
            insert(key: number, value: number): void;
            previousOrEqualValue(key: number): number;
            lookupValue(key: number): number;
        }
        interface KLongMap<V> {
            contains(key: number): boolean;
            get(key: number): V;
            put(key: number, value: V): void;
            each(callback: memory.chunk.KLongMapCallBack<V>): void;
            size(): number;
            clear(): void;
        }
        interface KLongMapCallBack<V> {
            (key: number, value: V): void;
        }
        interface KLongTree extends memory.chunk.KTree {
            insertKey(key: number): void;
            previousOrEqual(key: number): number;
            lookup(key: number): number;
            range(startKey: number, endKey: number, walker: memory.chunk.KTreeWalker): void;
        }
        interface KObjectChunk extends memory.KChunk {
            clone(p_universe: number, p_time: number, p_obj: number, p_metaClass: meta.KMetaModel): memory.chunk.KObjectChunk;
            metaClassIndex(): number;
            toJSON(metaModel: meta.KMetaModel): string;
            setPrimitiveType(index: number, content: any, metaClass: meta.KMetaClass): void;
            getPrimitiveType(index: number, metaClass: meta.KMetaClass): any;
            getLongArray(index: number, metaClass: meta.KMetaClass): Float64Array;
            getLongArraySize(index: number, metaClass: meta.KMetaClass): number;
            getLongArrayElem(index: number, refIndex: number, metaClass: meta.KMetaClass): number;
            addLongToArray(index: number, newRef: number, metaClass: meta.KMetaClass): boolean;
            removeLongToArray(index: number, previousRef: number, metaClass: meta.KMetaClass): boolean;
            clearLongArray(index: number, metaClass: meta.KMetaClass): void;
            getDoubleArray(index: number, metaClass: meta.KMetaClass): Float64Array;
            getDoubleArraySize(index: number, metaClass: meta.KMetaClass): number;
            getDoubleArrayElem(index: number, arrayIndex: number, metaClass: meta.KMetaClass): number;
            setDoubleArrayElem(index: number, arrayIndex: number, valueToInsert: number, metaClass: meta.KMetaClass): void;
            extendDoubleArray(index: number, newSize: number, metaClass: meta.KMetaClass): void;
            clearDoubleArray(index: number, metaClass: meta.KMetaClass): void;
        }
        interface KObjectIndexChunk extends memory.chunk.KObjectChunk, memory.chunk.KStringLongMap {
        }
        interface KStringLongMap {
            contains(key: string): boolean;
            get(key: string): number;
            put(key: string, value: number): void;
            each(callback: memory.chunk.KStringLongMapCallBack): void;
            size(): number;
            clear(): void;
            remove(key: string): void;
        }
        interface KStringLongMapCallBack {
            (key: string, value: number): void;
        }
        interface KStringMap<V> {
            contains(key: string): boolean;
            get(key: string): V;
            put(key: string, value: V): void;
            each(callback: memory.chunk.KStringMapCallBack<V>): void;
            size(): number;
            clear(): void;
            remove(key: string): void;
        }
        interface KStringMapCallBack<V> {
            (key: string, value: V): void;
        }
        interface KTree extends memory.KChunk {
            size(): number;
        }
        interface KTreeWalker {
            (t: number): void;
        }
        namespace impl {
            class AbstractArrayTree implements memory.KChunk {
                private static BLACK_LEFT;
                private static BLACK_RIGHT;
                private static RED_LEFT;
                private static RED_RIGHT;
                private static META_SIZE;
                private static LOAD_FACTOR;
                kvSize: number;
                private _threshold;
                private _root_index;
                private _size;
                private state;
                private _space;
                private _flags;
                private _counter;
                private _universe;
                private _time;
                private _obj;
                constructor(p_universe: number, p_time: number, p_obj: number, p_space: memory.space.KChunkSpace);
                counter(): number;
                inc(): number;
                dec(): number;
                universe(): number;
                time(): number;
                obj(): number;
                getFlags(): number;
                setFlags(bitsToEnable: number, bitsToDisable: number): void;
                space(): memory.space.KChunkSpace;
                private allocate(capacity);
                private reallocate(newCapacity);
                size(): number;
                key(p_currentIndex: number): number;
                private setKey(p_currentIndex, p_paramIndex);
                value(p_currentIndex: number): number;
                private setValue(p_currentIndex, p_paramIndex);
                private left(p_currentIndex);
                private setLeft(p_currentIndex, p_paramIndex);
                private right(p_currentIndex);
                private setRight(p_currentIndex, p_paramIndex);
                private parent(p_currentIndex);
                private setParent(p_currentIndex, p_paramIndex);
                private color(p_currentIndex);
                private setColor(p_currentIndex, p_paramIndex);
                private grandParent(p_currentIndex);
                private sibling(p_currentIndex);
                private uncle(p_currentIndex);
                private previous(p_index);
                private next(p_index);
                lookup(p_key: number): number;
                range(startKey: number, endKey: number, walker: memory.chunk.KTreeWalker): void;
                internal_previousOrEqual_index(p_key: number): number;
                private rotateLeft(n);
                private rotateRight(n);
                private replaceNode(oldn, newn);
                private insertCase1(n);
                private insertCase2(n);
                private insertCase3(n);
                private insertCase4(n_n);
                private insertCase5(n);
                serialize(metaModel: meta.KMetaModel): string;
                init(payload: string, metaModel: meta.KMetaModel, metaClassIndex: number): void;
                free(p_metaModel: meta.KMetaModel): void;
                internal_insert(p_key: number, p_value: number): void;
                internal_lookup_value(p_key: number): number;
                private internal_set_dirty();
                type(): number;
                dependencies(): Float64Array;
                addDependency(universe: number, time: number, uuid: number): void;
            }
            namespace AbstractArrayTree {
                class InternalState {
                    _back_meta: Int32Array;
                    _back_kv: Float64Array;
                    _back_colors: boolean[];
                    constructor(_back_meta: Int32Array, _back_kv: Float64Array, _back_colors: boolean[]);
                }
            }
            class ArrayIntMap<V> implements memory.chunk.KIntMap<V> {
                constructor(initalCapacity: number, loadFactor: number);
                clear(): void;
                get(key: number): V;
                put(key: number, pval: V): V;
                contains(key: number): boolean;
                remove(key: number): V;
                size(): number;
                each(callback: (p: number, p1: V) => void): void;
            }
            class ArrayLongLongMap implements memory.chunk.KLongLongMap {
                elementCount: number;
                droppedCount: number;
                state: memory.chunk.impl.ArrayLongLongMap.InternalState;
                threshold: number;
                private initialCapacity;
                private static loadFactor;
                private _flags;
                private _counter;
                private _space;
                private _universe;
                private _time;
                private _obj;
                private _metaClassIndex;
                constructor(p_universe: number, p_time: number, p_obj: number, p_space: memory.space.KChunkSpace);
                counter(): number;
                inc(): number;
                dec(): number;
                clear(): void;
                rehashCapacity(capacity: number): void;
                each(callback: memory.chunk.KLongLongMapCallBack<any>): void;
                metaClassIndex(): number;
                contains(key: number): boolean;
                get(key: number): number;
                put(key: number, value: number): void;
                findNonNullKeyEntry(key: number, index: number): number;
                remove(key: number): void;
                size(): number;
                init(payload: string, metaModel: meta.KMetaModel, metaClassIndex: number): void;
                serialize(metaModel: meta.KMetaModel): string;
                free(metaModel: meta.KMetaModel): void;
                type(): number;
                space(): memory.space.KChunkSpace;
                private internal_set_dirty();
                getFlags(): number;
                setFlags(bitsToEnable: number, bitsToDisable: number): void;
                universe(): number;
                time(): number;
                obj(): number;
                dependencies(): Float64Array;
                addDependency(universe: number, time: number, uuid: number): void;
            }
            namespace ArrayLongLongMap {
                class InternalState {
                    elementDataSize: number;
                    elementKV: Float64Array;
                    elementNext: Int32Array;
                    elementHash: Int32Array;
                    constructor(elementDataSize: number, elementKV: Float64Array, elementNext: Int32Array, elementHash: Int32Array);
                }
            }
            class ArrayLongLongTree extends memory.chunk.impl.AbstractArrayTree implements memory.chunk.KLongLongTree {
                constructor(p_universe: number, p_time: number, p_obj: number, p_space: memory.space.KChunkSpace);
                previousOrEqualValue(p_key: number): number;
                lookupValue(p_key: number): number;
                insert(p_key: number, p_value: number): void;
                type(): number;
            }
            class ArrayLongMap<V> implements memory.chunk.KLongMap<V> {
                constructor(initalCapacity: number, loadFactor: number);
                clear(): void;
                get(key: number): V;
                put(key: number, pval: V): V;
                contains(key: number): boolean;
                remove(key: number): V;
                size(): number;
                each(callback: (p: number, p1: V) => void): void;
            }
            class ArrayLongTree extends memory.chunk.impl.AbstractArrayTree implements memory.chunk.KLongTree {
                constructor(p_universe: number, p_time: number, p_obj: number, p_space: memory.space.KChunkSpace);
                previousOrEqual(key: number): number;
                insertKey(p_key: number): void;
                type(): number;
            }
            class ArrayStringMap<V> implements memory.chunk.KStringMap<V> {
                constructor(initalCapacity: number, loadFactor: number);
                clear(): void;
                get(key: string): V;
                put(key: string, pval: V): V;
                contains(key: string): boolean;
                remove(key: string): V;
                size(): number;
                each(callback: (p: string, p1: V) => void): void;
            }
            class HeapObjectChunk implements memory.chunk.KObjectChunk {
                private _space;
                private _flags;
                private _counter;
                private _dependencies;
                private _universe;
                private _time;
                private _obj;
                private raw;
                private _metaClassIndex;
                constructor(p_universe: number, p_time: number, p_obj: number, p_space: memory.space.KChunkSpace);
                space(): memory.space.KChunkSpace;
                metaClassIndex(): number;
                serialize(metaModel: meta.KMetaModel): string;
                private loadObject(metaAttribute, p_payload, p_start, p_end);
                init(payload: string, metaModel: meta.KMetaModel, metaClassIndex: number): void;
                counter(): number;
                inc(): number;
                dec(): number;
                free(metaModel: meta.KMetaModel): void;
                type(): number;
                getPrimitiveType(index: number, p_metaClass: meta.KMetaClass): any;
                getLongArraySize(index: number, metaClass: meta.KMetaClass): number;
                getLongArrayElem(index: number, refIndex: number, metaClass: meta.KMetaClass): number;
                getLongArray(index: number, p_metaClass: meta.KMetaClass): Float64Array;
                addLongToArray(index: number, newRef: number, metaClass: meta.KMetaClass): boolean;
                removeLongToArray(index: number, refToRemove: number, metaClass: meta.KMetaClass): boolean;
                clearLongArray(index: number, metaClass: meta.KMetaClass): void;
                getDoubleArray(index: number, metaClass: meta.KMetaClass): Float64Array;
                getDoubleArraySize(index: number, metaClass: meta.KMetaClass): number;
                getDoubleArrayElem(index: number, arrayIndex: number, metaClass: meta.KMetaClass): number;
                setDoubleArrayElem(index: number, arrayIndex: number, valueToInsert: number, metaClass: meta.KMetaClass): void;
                extendDoubleArray(index: number, newSize: number, metaClass: meta.KMetaClass): void;
                clearDoubleArray(index: number, metaClass: meta.KMetaClass): void;
                setPrimitiveType(index: number, content: any, p_metaClass: meta.KMetaClass): void;
                clone(p_universe: number, p_time: number, p_obj: number, p_metaClass: meta.KMetaModel): memory.chunk.KObjectChunk;
                toJSON(metaModel: meta.KMetaModel): string;
                private internal_set_dirty();
                getFlags(): number;
                setFlags(bitsToEnable: number, bitsToDisable: number): void;
                universe(): number;
                time(): number;
                obj(): number;
                dependencies(): Float64Array;
                addDependency(universe: number, time: number, uuid: number): void;
            }
            class HeapObjectIndexChunk implements memory.chunk.KObjectIndexChunk {
                elementCount: number;
                droppedCount: number;
                state: memory.chunk.impl.HeapObjectIndexChunk.InternalState;
                threshold: number;
                private initialCapacity;
                private static loadFactor;
                private _flags;
                private _counter;
                private _space;
                private _universe;
                private _time;
                private _obj;
                private _metaClassIndex;
                private _dependencies;
                constructor(p_universe: number, p_time: number, p_obj: number, p_space: memory.space.KChunkSpace);
                clone(p_universe: number, p_time: number, p_obj: number, p_metaClass: meta.KMetaModel): memory.chunk.KObjectChunk;
                metaClassIndex(): number;
                toJSON(metaModel: meta.KMetaModel): string;
                setPrimitiveType(index: number, content: any, metaClass: meta.KMetaClass): void;
                getPrimitiveType(index: number, metaClass: meta.KMetaClass): any;
                getLongArray(index: number, metaClass: meta.KMetaClass): Float64Array;
                getLongArraySize(index: number, metaClass: meta.KMetaClass): number;
                getLongArrayElem(index: number, refIndex: number, metaClass: meta.KMetaClass): number;
                addLongToArray(index: number, newRef: number, metaClass: meta.KMetaClass): boolean;
                removeLongToArray(index: number, previousRef: number, metaClass: meta.KMetaClass): boolean;
                clearLongArray(index: number, metaClass: meta.KMetaClass): void;
                getDoubleArray(index: number, metaClass: meta.KMetaClass): Float64Array;
                getDoubleArraySize(index: number, metaClass: meta.KMetaClass): number;
                getDoubleArrayElem(index: number, arrayIndex: number, metaClass: meta.KMetaClass): number;
                setDoubleArrayElem(index: number, arrayIndex: number, valueToInsert: number, metaClass: meta.KMetaClass): void;
                extendDoubleArray(index: number, newSize: number, metaClass: meta.KMetaClass): void;
                clearDoubleArray(index: number, metaClass: meta.KMetaClass): void;
                counter(): number;
                inc(): number;
                dec(): number;
                clear(): void;
                rehashCapacity(capacity: number): void;
                each(callback: memory.chunk.KStringLongMapCallBack): void;
                contains(key: string): boolean;
                get(key: string): number;
                put(key: string, value: number): void;
                findNonNullKeyEntry(key: string, index: number): number;
                remove(key: string): void;
                size(): number;
                init(payload: string, metaModel: meta.KMetaModel, metaClassIndex: number): void;
                serialize(metaModel: meta.KMetaModel): string;
                free(metaModel: meta.KMetaModel): void;
                type(): number;
                space(): memory.space.KChunkSpace;
                private internal_set_dirty();
                getFlags(): number;
                setFlags(bitsToEnable: number, bitsToDisable: number): void;
                universe(): number;
                time(): number;
                obj(): number;
                dependencies(): Float64Array;
                addDependency(universe: number, time: number, uuid: number): void;
            }
            namespace HeapObjectIndexChunk {
                class InternalState {
                    elementDataSize: number;
                    elementK: string[];
                    elementV: Float64Array;
                    elementNext: Int32Array;
                    elementHash: Int32Array;
                    constructor(elementDataSize: number, elementK: string[], elementV: Float64Array, elementNext: Int32Array, elementHash: Int32Array);
                    clone(): memory.chunk.impl.HeapObjectIndexChunk.InternalState;
                }
            }
        }
    }
    namespace manager {
        class DataManagerBuilder {
            private _driver;
            private _scheduler;
            private _strategy;
            private _blas;
            driver(): cdn.KContentDeliveryDriver;
            blas(): util.maths.structure.blas.KBlas;
            scheduler(): scheduler.KScheduler;
            strategy(): memory.strategy.KMemoryStrategy;
            static create(): memory.manager.DataManagerBuilder;
            withContentDeliveryDriver(p_driver: cdn.KContentDeliveryDriver): memory.manager.DataManagerBuilder;
            withScheduler(p_scheduler: scheduler.KScheduler): memory.manager.DataManagerBuilder;
            withMemoryStrategy(p_strategy: memory.strategy.KMemoryStrategy): memory.manager.DataManagerBuilder;
            withBlas(p_blas: util.maths.structure.blas.KBlas): memory.manager.DataManagerBuilder;
            build(): memory.manager.internal.KInternalDataManager;
            static buildDefault(): memory.manager.internal.KInternalDataManager;
        }
        interface KDataManager {
            index(universe: number, time: number, indexName: string, callback: KCallback<KObjectIndex>): void;
            lookup(universe: number, time: number, uuid: number, callback: KCallback<KObject>): void;
            lookupAllObjects(universe: number, time: number, uuids: Float64Array, callback: KCallback<KObject[]>): void;
            lookupAllTimes(universe: number, times: Float64Array, uuid: number, callback: KCallback<KObject[]>): void;
            createPreparedLookup(size: number): KPreparedLookup;
            lookupPrepared(prepared: KPreparedLookup, callback: KCallback<KObject[]>): void;
            save(callback: KCallback<Error>): void;
            model(): KModel<any>;
            connect(callback: KCallback<Error>): void;
            close(callback: KCallback<Error>): void;
            blas(): util.maths.structure.blas.KBlas;
        }
        namespace impl {
            class DataManager implements memory.manager.KDataManager, memory.manager.internal.KInternalDataManager {
                private static UNIVERSE_NOT_CONNECTED_ERROR;
                private _operationManager;
                private _db;
                private _scheduler;
                private _listenerManager;
                private _modelKeyCalculator;
                private _resolver;
                private _space;
                private _spaceManager;
                private _blas;
                private _objectKeyCalculator;
                private _universeKeyCalculator;
                private isConnected;
                private _prefix;
                private _model;
                private static UNIVERSE_INDEX;
                private static OBJ_INDEX;
                private static GLO_TREE_INDEX;
                private static zeroPrefix;
                private currentCdnListener;
                private static PREFIX_TO_SAVE_SIZE;
                private static KEY_SIZE;
                setModel(p_model: KModel<any>): void;
                constructor(p_cdn: cdn.KContentDeliveryDriver, p_scheduler: scheduler.KScheduler, p_factory: memory.strategy.KMemoryStrategy, p_blas: util.maths.structure.blas.KBlas);
                model(): KModel<any>;
                blas(): util.maths.structure.blas.KBlas;
                nextUniverseKey(): number;
                nextObjectKey(): number;
                nextModelKey(): number;
                initUniverse(p_universe: number, p_parent: number): void;
                save(callback: KCallback<Error>): void;
                initKObject(obj: KObject): void;
                preciseChunk(universe: number, time: number, uuid: number, metaClass: meta.KMetaClass, previousResolution: java.util.concurrent.atomic.AtomicReference<Float64Array>): memory.chunk.KObjectChunk;
                closestChunk(universe: number, time: number, uuid: number, metaClass: meta.KMetaClass, previousResolution: java.util.concurrent.atomic.AtomicReference<Float64Array>): memory.chunk.KObjectChunk;
                connect(connectCallback: KCallback<Error>): void;
                close(callback: KCallback<Error>): void;
                deleteUniverse(p_universe: KUniverse<any, any>, callback: KCallback<Error>): void;
                lookup(universe: number, time: number, uuid: number, callback: KCallback<KObject>): void;
                lookupAllObjects(universe: number, time: number, uuids: Float64Array, callback: KCallback<KObject[]>): void;
                lookupAllTimes(universe: number, times: Float64Array, uuid: number, callback: KCallback<KObject[]>): void;
                createPreparedLookup(p_size: number): KPreparedLookup;
                lookupPrepared(prepared: KPreparedLookup, callback: KCallback<KObject[]>): void;
                cdn(): cdn.KContentDeliveryDriver;
                scheduler(): scheduler.KScheduler;
                private attachContentDeliveryDriver(p_dataBase);
                operationManager(): operation.KOperationManager;
                createListener(p_universe: number): KListener;
                resolveTimes(currentUniverse: number, currentUuid: number, startTime: number, endTime: number, callback: KCallback<Float64Array>): void;
                spaceSize(): number;
                printDebug(): void;
                index(universe: number, time: number, indexName: string, callback: KCallback<KObjectIndex>): void;
            }
            class HeapListener implements KListener {
                private _universe;
                private _listenerManager;
                private _id;
                cb: KCallback<KObject>;
                listenerID(): number;
                constructor(p_universe: number, p_listenerManager: memory.manager.impl.ListenerManager, p_id: number);
                universe(): number;
                listenObjects(): Float64Array;
                listen(obj: KObject): void;
                destroy(): void;
                then(p_cb: KCallback<any>): void;
            }
            class KeyCalculator {
                private _prefix;
                private _currentIndex;
                constructor(prefix: number, currentIndex: number);
                nextKey(): number;
                lastComputedIndex(): number;
                prefix(): number;
            }
            class ListenerManager {
                private _keyGen;
                _listeners: memory.chunk.impl.ArrayLongMap<memory.manager.impl.HeapListener>;
                _listener2Objects: memory.chunk.impl.ArrayLongMap<Float64Array>;
                _obj2Listener: memory.chunk.impl.ArrayLongMap<Float64Array>;
                constructor();
                clear(): void;
                createListener(p_universe: number): KListener;
                manageRegistration(listenerID: number, origin: KObject): void;
                isListened(obj: number): boolean;
                dispatch(objects: KObject[]): void;
            }
            class PreparedLookup implements KPreparedLookup {
                private _size;
                private _flatStatement;
                private _current;
                constructor(p_size: number);
                addLookupOperation(universe: number, time: number, uuid: number): void;
                flatLookup(): Float64Array;
            }
        }
        namespace internal {
            interface KInternalDataManager extends memory.manager.KDataManager {
                createListener(universe: number): KListener;
                cdn(): cdn.KContentDeliveryDriver;
                scheduler(): scheduler.KScheduler;
                preciseChunk(universe: number, time: number, uuid: number, metaClass: meta.KMetaClass, previousResolution: java.util.concurrent.atomic.AtomicReference<Float64Array>): memory.chunk.KObjectChunk;
                closestChunk(universe: number, time: number, uuid: number, metaClass: meta.KMetaClass, previousResolution: java.util.concurrent.atomic.AtomicReference<Float64Array>): memory.chunk.KObjectChunk;
                initKObject(obj: KObject): void;
                initUniverse(universe: number, parent: number): void;
                nextUniverseKey(): number;
                nextObjectKey(): number;
                nextModelKey(): number;
                deleteUniverse(universe: KUniverse<any, any>, callback: KCallback<Error>): void;
                operationManager(): operation.KOperationManager;
                setModel(model: KModel<any>): void;
                resolveTimes(currentUniverse: number, currentUuid: number, startTime: number, endTime: number, callback: KCallback<Float64Array>): void;
                spaceSize(): number;
                printDebug(): void;
            }
        }
    }
    namespace resolver {
        interface KResolver {
            lookup(universe: number, time: number, uuid: number, callback: KCallback<KObject>): scheduler.KTask;
            lookupAllObjects(universe: number, time: number, uuids: Float64Array, callback: KCallback<KObject[]>): scheduler.KTask;
            lookupAllTimes(universe: number, times: Float64Array, uuid: number, callback: KCallback<KObject[]>): scheduler.KTask;
            lookupPreciseKeys(keys: Float64Array, callback: KCallback<KObject[]>): scheduler.KTask;
            lookupPrepared(preparedLookup: KPreparedLookup, callback: KCallback<KObject[]>): scheduler.KTask;
            preciseChunk(universe: number, time: number, uuid: number, metaClass: meta.KMetaClass, previousResolution: java.util.concurrent.atomic.AtomicReference<Float64Array>): memory.chunk.KObjectChunk;
            closestChunk(universe: number, time: number, uuid: number, metaClass: meta.KMetaClass, previousResolution: java.util.concurrent.atomic.AtomicReference<Float64Array>): memory.chunk.KObjectChunk;
            indexObject(obj: KObject): void;
            resolveTimes(currentUniverse: number, currentUuid: number, startTime: number, endTime: number, callback: KCallback<Float64Array>): void;
            getRelatedKeysResultSize(): number;
            getRelatedKeys(universe: number, time: number, uuid: number, result: Float64Array): void;
        }
        namespace impl {
            class DistortedTimeResolver implements memory.resolver.KResolver {
                private static KEYS_SIZE;
                private _spaceManager;
                private _manager;
                constructor(p_cache: memory.space.KChunkSpaceManager, p_manager: memory.manager.internal.KInternalDataManager);
                lookup(universe: number, time: number, uuid: number, callback: KCallback<KObject>): scheduler.KTask;
                lookupAllObjects(universe: number, time: number, uuids: Float64Array, callback: KCallback<KObject[]>): scheduler.KTask;
                lookupPreciseKeys(keys: Float64Array, callback: KCallback<KObject[]>): scheduler.KTask;
                lookupPrepared(preparedLookup: KPreparedLookup, callback: KCallback<KObject[]>): scheduler.KTask;
                lookupAllTimes(universe: number, times: Float64Array, uuid: number, callback: KCallback<KObject[]>): scheduler.KTask;
                preciseChunk(universe: number, time: number, uuid: number, metaClass: meta.KMetaClass, previousResolution: java.util.concurrent.atomic.AtomicReference<Float64Array>): memory.chunk.KObjectChunk;
                closestChunk(universe: number, time: number, uuid: number, metaClass: meta.KMetaClass, previousResolution: java.util.concurrent.atomic.AtomicReference<Float64Array>): memory.chunk.KObjectChunk;
                private internal_chunk(universe, requestedTime, uuid, useClosest, metaClass, previousResolution);
                indexObject(obj: KObject): void;
                getOrLoadAndMark(universe: number, time: number, uuid: number, callback: KCallback<memory.KChunk>): void;
                getOrLoadAndMarkAll(keys: Float64Array, callback: KCallback<memory.KChunk[]>): void;
                resolveTimes(currentUniverse: number, currentUuid: number, startTime: number, endTime: number, callback: KCallback<Float64Array>): void;
                static resolve_universe(globalTree: memory.chunk.KLongLongMap, objUniverseTree: memory.chunk.KLongLongMap, timeToResolve: number, originUniverseId: number): number;
                static universeSelectByRange(globalTree: memory.chunk.KLongLongMap, objUniverseTree: memory.chunk.KLongLongMap, rangeMin: number, rangeMax: number, originUniverseId: number): Float64Array;
                private load(keys, callback);
                getRelatedKeysResultSize(): number;
                getRelatedKeys(universe: number, time: number, uuid: number, result: Float64Array): void;
            }
        }
    }
    namespace space {
        interface KChunkIterator {
            hasNext(): boolean;
            next(): Float64Array;
            size(): number;
        }
        interface KChunkSpace {
            get(universe: number, time: number, obj: number): memory.KChunk;
            create(universe: number, time: number, obj: number, type: number): memory.KChunk;
            clone(previousElement: memory.chunk.KObjectChunk, newUniverse: number, newTime: number, newObj: number, metaModel: meta.KMetaModel): memory.chunk.KObjectChunk;
            clear(metaModel: meta.KMetaModel): void;
            free(metaModel: meta.KMetaModel): void;
            remove(universe: number, time: number, obj: number, metaModel: meta.KMetaModel): void;
            size(): number;
            detachDirties(): memory.space.KChunkIterator;
            declareDirty(dirtyChunk: memory.KChunk): void;
            printDebug(p_metaModel: meta.KMetaModel): void;
        }
        interface KChunkSpaceManager {
            getAndMark(universe: number, time: number, obj: number): memory.KChunk;
            unmark(universe: number, time: number, obj: number): void;
            createAndMark(universe: number, time: number, obj: number, type: number): memory.KChunk;
            unmarkMemoryElement(element: memory.KChunk): void;
            markMemoryElement(element: memory.KChunk): void;
            unmarkAllMemoryElements(elements: memory.KChunk[]): void;
            cloneAndMark(previous: memory.chunk.KObjectChunk, newUniverse: number, newTime: number, obj: number, metaModel: meta.KMetaModel): memory.chunk.KObjectChunk;
            clear(): void;
            register(object: KObject): void;
            registerAll(objects: KObject[]): void;
            setResolver(resolver: memory.resolver.KResolver): void;
        }
        class KChunkTypes {
            static OBJECT_CHUNK: number;
            static OBJECT_CHUNK_INDEX: number;
            static LONG_TREE: number;
            static LONG_LONG_MAP: number;
        }
        namespace impl {
            class AbstractCountingChunkSpaceManager implements memory.space.KChunkSpaceManager {
                _space: memory.space.KChunkSpace;
                _metaModel: meta.KMetaModel;
                constructor(p_storage: memory.space.KChunkSpace);
                getAndMark(universe: number, time: number, obj: number): memory.KChunk;
                unmark(universe: number, time: number, obj: number): void;
                createAndMark(universe: number, time: number, obj: number, type: number): memory.KChunk;
                unmarkMemoryElement(element: memory.KChunk): void;
                markMemoryElement(element: memory.KChunk): void;
                unmarkAllMemoryElements(elements: memory.KChunk[]): void;
                private cleanDependenciesAndPotentiallyRemoveChunk(toRemoveChunk);
                cloneAndMark(previous: memory.chunk.KObjectChunk, newUniverse: number, newTime: number, obj: number, metaModel: meta.KMetaModel): memory.chunk.KObjectChunk;
                clear(): void;
                register(object: KObject): void;
                registerAll(objects: KObject[]): void;
                setResolver(resolver: memory.resolver.KResolver): void;
            }
            class ChunkIterator implements memory.space.KChunkIterator {
                private _dirties;
                private _origin;
                private currentIndex;
                private maxIndex;
                private tempKeys;
                constructor(p_dirties: Float64Array, p_origin: memory.space.KChunkSpace);
                hasNext(): boolean;
                next(): Float64Array;
                size(): number;
            }
            class HeapChunkSpace implements memory.space.KChunkSpace {
                private static LOAD_FACTOR;
                private _state;
                private _dirtyState;
                constructor();
                get(universe: number, time: number, obj: number): memory.KChunk;
                create(universe: number, time: number, obj: number, type: number): memory.KChunk;
                clone(previousElement: memory.chunk.KObjectChunk, newUniverse: number, newTime: number, newObj: number, metaModel: meta.KMetaModel): memory.chunk.KObjectChunk;
                private internal_createElement(p_universe, p_time, p_obj, type);
                private internal_put(universe, time, p_obj, payload);
                private complex_insert(universe, time, p_obj, payload, prehash, nextValueIndex);
                private rehashCapacity(previousState);
                findNonNullKeyEntry(universe: number, time: number, obj: number, index: number, internalState: memory.space.impl.HeapChunkSpace.InternalState): number;
                detachDirties(): memory.space.KChunkIterator;
                declareDirty(dirtyChunk: memory.KChunk): void;
                remove(universe: number, time: number, obj: number, p_metaModel: meta.KMetaModel): void;
                clear(metaModel: meta.KMetaModel): void;
                free(metaModel: meta.KMetaModel): void;
                printDebug(p_metaModel: meta.KMetaModel): void;
                size(): number;
            }
            namespace HeapChunkSpace {
                class InternalState {
                    sparse: boolean;
                    elementDataSize: number;
                    elementK3: Float64Array;
                    elementNext: Int32Array;
                    elementHash: java.util.concurrent.atomic.AtomicIntegerArray;
                    values: memory.KChunk[];
                    _elementCount: java.util.concurrent.atomic.AtomicInteger;
                    _valuesIndex: java.util.concurrent.atomic.AtomicInteger;
                    _threshold: number;
                    constructor(p_elementDataSize: number, p_elementKE: Float64Array, p_elementNext: Int32Array, p_elementHash: Int32Array, p_values: memory.KChunk[]);
                }
                class InternalDirtyState {
                    _dirtyList: Float64Array;
                    _dirtyIndex: java.util.concurrent.atomic.AtomicInteger;
                    constructor();
                    declareDirty(universe: number, time: number, obj: number): void;
                    private reallocate(wantedIndex);
                }
            }
            class NoopChunkSpaceManager implements memory.space.KChunkSpaceManager {
                private _space;
                constructor(p_space: memory.space.KChunkSpace);
                getAndMark(universe: number, time: number, obj: number): memory.KChunk;
                unmark(universe: number, time: number, obj: number): void;
                createAndMark(universe: number, time: number, obj: number, type: number): memory.KChunk;
                unmarkMemoryElement(element: memory.KChunk): void;
                markMemoryElement(element: memory.KChunk): void;
                unmarkAllMemoryElements(elements: memory.KChunk[]): void;
                cloneAndMark(previous: memory.chunk.KObjectChunk, newUniverse: number, newTime: number, obj: number, metaModel: meta.KMetaModel): memory.chunk.KObjectChunk;
                clear(): void;
                register(object: KObject): void;
                registerAll(objects: KObject[]): void;
                setResolver(resolver: memory.resolver.KResolver): void;
            }
        }
    }
    namespace strategy {
        interface KMemoryStrategy {
            newSpace(): memory.space.KChunkSpace;
            newSpaceManager(space: memory.space.KChunkSpace, scheduler: scheduler.KScheduler): memory.space.KChunkSpaceManager;
        }
        namespace impl {
            class HeapMemoryStrategy implements memory.strategy.KMemoryStrategy {
                newSpace(): memory.space.KChunkSpace;
                newSpaceManager(p_space: memory.space.KChunkSpace, p_scheduler: scheduler.KScheduler): memory.space.KChunkSpaceManager;
            }
        }
    }
}
export declare namespace message {
    interface KMessage {
        id(): number;
        setID(val: number): void;
        type(): number;
        setType(val: number): void;
        operationName(): string;
        setOperationName(val: string): void;
        className(): string;
        setClassName(val: string): void;
        keys(): Float64Array;
        setKeys(val: Float64Array): void;
        values(): string[];
        setValues(val: string[]): void;
        values2(): string[];
        setValues2(val: string[]): void;
        peer(): string;
        setPeer(val: string): void;
        save(): string;
    }
    namespace impl {
        class Message implements message.KMessage {
            private static TYPE_INDEX;
            private static ID_INDEX;
            private static OPERATION_INDEX;
            private static CLASS_INDEX;
            private static PEER_INDEX;
            private static KEYS_INDEX;
            private static VALUES_INDEX;
            private static VALUES2_INDEX;
            private static KEYS_NAME;
            static EVENTS_TYPE: number;
            static GET_REQ_TYPE: number;
            static GET_RES_TYPE: number;
            static PUT_REQ_TYPE: number;
            static PUT_RES_TYPE: number;
            static OPERATION_CALL_TYPE: number;
            static OPERATION_RESULT_TYPE: number;
            static ATOMIC_GET_INC_REQUEST_TYPE: number;
            static ATOMIC_GET_INC_RESULT_TYPE: number;
            static OPERATION_MAPPING: number;
            private static NB_ELEM;
            private internal;
            id(): number;
            setID(val: number): void;
            type(): number;
            setType(val: number): void;
            operationName(): string;
            setOperationName(val: string): void;
            className(): string;
            setClassName(val: string): void;
            keys(): Float64Array;
            setKeys(val: Float64Array): void;
            values(): string[];
            setValues(val: string[]): void;
            values2(): string[];
            setValues2(val: string[]): void;
            peer(): string;
            setPeer(val: string): void;
            save(): string;
            static load(payload: string): message.KMessage;
        }
    }
}
export declare namespace meta {
    interface KLiteral extends meta.KMeta {
    }
    interface KMeta {
        index(): number;
        metaName(): string;
        metaType(): meta.MetaType;
    }
    interface KMetaAttribute extends meta.KMeta {
        key(): boolean;
        attributeTypeId(): number;
        strategy(): extrapolation.Extrapolation;
        precision(): number;
        setExtrapolation(extrapolation: extrapolation.Extrapolation): void;
        setPrecision(precision: number): void;
        setKey(key: boolean): void;
    }
    interface KMetaClass extends meta.KMeta {
        metaElements(): meta.KMeta[];
        meta(index: number): meta.KMeta;
        metaByName(name: string): meta.KMeta;
        metaParents(): Int32Array;
        attribute(name: string): meta.KMetaAttribute;
        reference(name: string): meta.KMetaRelation;
        operation(name: string): meta.KMetaOperation;
        addAttribute(attributeName: string, p_type: KType): meta.KMetaAttribute;
        addRelation(relationName: string, metaClass: meta.KMetaClass, oppositeName: string): meta.KMetaRelation;
        addDependency(dependencyName: string, referredMetaClassIndex: number): meta.KMetaDependency;
        addInput(dependencyName: string, extractor: string): meta.KMetaInferInput;
        addOutput(name: string, metaClass: KType): meta.KMetaInferOutput;
        addOperation(operationName: string): meta.KMetaOperation;
        inferAlg(): infer.KInferAlg;
        dependencies(): meta.KMetaDependencies;
        inputs(): meta.KMetaInferInput[];
        outputs(): meta.KMetaInferOutput[];
        temporalResolution(): number;
        setTemporalResolution(tempo: number): void;
        addParent(parentMetaClass: meta.KMeta): void;
    }
    interface KMetaDependencies extends meta.KMeta {
        origin(): meta.KMetaClass;
        allDependencies(): meta.KMetaDependency[];
        dependencyByName(dependencyName: string): meta.KMetaDependency;
        addDependency(dependencyName: string, p_referredMetaClassIndex: number): meta.KMetaDependency;
    }
    interface KMetaDependency extends meta.KMeta {
        referredMetaClassIndex(): number;
    }
    interface KMetaEnum extends KType, meta.KMeta {
        literals(): meta.KLiteral[];
        literalByName(name: string): meta.KLiteral;
        literal(index: number): meta.KLiteral;
        addLiteral(name: string): meta.KLiteral;
    }
    interface KMetaInferInput extends meta.KMeta {
        extractorQuery(): string;
        extractor(): traversal.KTraversal;
    }
    interface KMetaInferOutput extends meta.KMeta {
        attributeTypeId(): number;
    }
    interface KMetaModel extends meta.KMeta {
        metaClasses(): meta.KMetaClass[];
        metaClassByName(name: string): meta.KMetaClass;
        metaClass(index: number): meta.KMetaClass;
        addMetaClass(metaClassName: string): meta.KMetaClass;
        addInferMetaClass(metaClassName: string, inferAlg: infer.KInferAlg): meta.KMetaClass;
        metaTypes(): meta.KMetaEnum[];
        metaTypeByName(name: string): meta.KMetaEnum;
        addMetaEnum(enumName: string): meta.KMetaEnum;
        createModel(manager: memory.manager.internal.KInternalDataManager): KModel<any>;
    }
    interface KMetaOperation extends meta.KMeta {
        originMetaClassIndex(): number;
        paramTypes(): Int32Array;
        paramMultiplicities(): boolean[];
        returnType(): number;
        returnTypeIsArray(): boolean;
        addParam(type: KType, isArray: boolean): void;
        setReturnType(type: KType, isArray: boolean): void;
    }
    interface KMetaRelation extends meta.KMeta {
        originMetaClassIndex(): number;
        referredMetaClassIndex(): number;
        oppositeName(): string;
        visible(): boolean;
        maxBound(): number;
        setMaxBound(bound: number): void;
    }
    class KPrimitiveTypes {
        static BOOL_ID: number;
        static STRING_ID: number;
        static LONG_ID: number;
        static INT_ID: number;
        static DOUBLE_ID: number;
        static CONTINUOUS_ID: number;
        static BOOL: KType;
        static STRING: KType;
        static LONG: KType;
        static INT: KType;
        static DOUBLE: KType;
        static CONTINUOUS: KType;
        static isEnum(attributeTypeId: number): boolean;
    }
    class MetaType {
        static ATTRIBUTE: MetaType;
        static RELATION: MetaType;
        static DEPENDENCY: MetaType;
        static DEPENDENCIES: MetaType;
        static INPUT: MetaType;
        static OUTPUT: MetaType;
        static OPERATION: MetaType;
        static CLASS: MetaType;
        static MODEL: MetaType;
        static ENUM: MetaType;
        static LITERAL: MetaType;
        equals(other: any): boolean;
        static _MetaTypeVALUES: MetaType[];
        static values(): MetaType[];
    }
    namespace impl {
        class GenericModel extends abs.AbstractKModel<any> {
            private _p_metaModel;
            constructor(mm: meta.KMetaModel, p_manager: memory.manager.internal.KInternalDataManager);
            metaModel(): meta.KMetaModel;
            internalCreateUniverse(universe: number): KUniverse<any, any>;
            internalCreateObject(universe: number, time: number, uuid: number, clazz: meta.KMetaClass, previousUniverse: number, previousTime: number): KObject;
        }
        class GenericObject extends abs.AbstractKObject {
            constructor(p_universe: number, p_time: number, p_uuid: number, p_metaClass: meta.KMetaClass, p_manager: memory.manager.internal.KInternalDataManager, currentUniverse: number, currentTime: number);
        }
        class GenericObjectIndex extends abs.AbstractKObjectIndex {
            constructor(p_universe: number, p_time: number, p_uuid: number, p_manager: memory.manager.internal.KInternalDataManager, currentUniverse: number, currentTime: number);
        }
        class GenericObjectInfer extends abs.AbstractKObjectInfer {
            constructor(p_universe: number, p_time: number, p_uuid: number, p_metaClass: meta.KMetaClass, p_manager: memory.manager.internal.KInternalDataManager, currentUniverse: number, currentTime: number);
        }
        class GenericUniverse extends abs.AbstractKUniverse<any, any> {
            constructor(p_key: number, p_manager: memory.manager.internal.KInternalDataManager);
            internal_create(timePoint: number): KView;
        }
        class GenericView extends abs.AbstractKView {
            constructor(p_universe: number, _time: number, p_manager: memory.manager.internal.KInternalDataManager);
        }
        class MetaAttribute implements meta.KMetaAttribute {
            private _name;
            private _index;
            _precision: number;
            private _key;
            private _attributeTypeId;
            private _extrapolation;
            attributeTypeId(): number;
            index(): number;
            metaName(): string;
            metaType(): meta.MetaType;
            precision(): number;
            key(): boolean;
            strategy(): extrapolation.Extrapolation;
            setExtrapolation(extrapolation: extrapolation.Extrapolation): void;
            setPrecision(p_precision: number): void;
            setKey(p_key: boolean): void;
            constructor(p_name: string, p_index: number, p_precision: number, p_key: boolean, p_attributeTypeId: number, p_extrapolation: extrapolation.Extrapolation);
        }
        class MetaClass implements meta.KMetaClass {
            private _name;
            private _index;
            private _meta;
            private _indexes;
            private _alg;
            private _cachedInputs;
            private _cachedOutputs;
            private _parents;
            private _temporalResolution;
            constructor(p_name: string, p_index: number, p_alg: infer.KInferAlg, p_parents: Int32Array);
            init(p_metaElements: meta.KMeta[]): void;
            metaByName(name: string): meta.KMeta;
            metaParents(): Int32Array;
            attribute(name: string): meta.KMetaAttribute;
            reference(name: string): meta.KMetaRelation;
            operation(name: string): meta.KMetaOperation;
            metaElements(): meta.KMeta[];
            index(): number;
            metaName(): string;
            metaType(): meta.MetaType;
            meta(index: number): meta.KMeta;
            addAttribute(attributeName: string, p_type: KType): meta.KMetaAttribute;
            private internal_addatt(attributeName, p_type);
            addRelation(relationName: string, p_metaClass: meta.KMetaClass, oppositeName: string): meta.KMetaRelation;
            private internal_addref(referenceName, p_metaClass, oppositeName);
            private getOrCreate(p_name, p_oppositeName, p_oppositeClass, p_visible);
            addOperation(operationName: string): meta.KMetaOperation;
            inferAlg(): infer.KInferAlg;
            addDependency(dependencyName: string, referredMetaClassIndex: number): meta.KMetaDependency;
            addInput(p_name: string, p_extractor: string): meta.KMetaInferInput;
            addOutput(p_name: string, p_type: KType): meta.KMetaInferOutput;
            dependencies(): meta.KMetaDependencies;
            inputs(): meta.KMetaInferInput[];
            private cacheInputs();
            outputs(): meta.KMetaInferOutput[];
            temporalResolution(): number;
            setTemporalResolution(p_tempo: number): void;
            private cacheOuputs();
            private clearCached();
            private internal_add_meta(p_new_meta);
            private internal_add_meta_noindex(p_new_meta);
            addParent(parentMetaClass: meta.KMeta): void;
        }
        class MetaClassIndex {
            static INSTANCE: meta.KMetaClass;
        }
        class MetaDependencies implements meta.KMetaDependencies {
            private _origin;
            private _dependencies;
            static DEPENDENCIES_NAME: string;
            private _index;
            private _indexes;
            constructor(p_index: number, p_origin: meta.KMetaClass);
            origin(): meta.KMetaClass;
            allDependencies(): meta.KMetaDependency[];
            dependencyByName(dependencyName: string): meta.KMetaDependency;
            index(): number;
            metaName(): string;
            metaType(): meta.MetaType;
            addDependency(p_dependencyName: string, p_referredMetaClassIndex: number): meta.KMetaDependency;
            private internal_add_dep(p_new_meta);
        }
        class MetaDependency implements meta.KMetaDependency {
            private _name;
            private _index;
            private _referredMetaClassIndex;
            referredMetaClassIndex(): number;
            index(): number;
            metaName(): string;
            metaType(): meta.MetaType;
            constructor(p_name: string, p_index: number, p_origin: meta.KMetaDependencies, p_referredMetaClassIndex: number);
        }
        class MetaEnum implements meta.KMetaEnum {
            private _name;
            private _index;
            private _literals;
            private _indexes;
            constructor(p_name: string, p_index: number);
            init(lits: meta.KLiteral[]): void;
            literals(): meta.KLiteral[];
            literalByName(p_name: string): meta.KLiteral;
            literal(p_index: number): meta.KLiteral;
            addLiteral(p_name: string): meta.KLiteral;
            name(): string;
            id(): number;
            index(): number;
            metaName(): string;
            metaType(): meta.MetaType;
            private internal_add_meta(p_new_meta);
        }
        class MetaInferInput implements meta.KMetaInferInput {
            private _name;
            private _index;
            private _extractor;
            private _cachedTraversal;
            constructor(p_name: string, p_index: number, p_extractor: string);
            extractorQuery(): string;
            extractor(): traversal.KTraversal;
            private cacheTraversal();
            index(): number;
            metaName(): string;
            metaType(): meta.MetaType;
        }
        class MetaInferOutput implements meta.KMetaInferOutput {
            private _name;
            private _index;
            private _type;
            constructor(p_name: string, p_index: number, p_type: number);
            index(): number;
            metaName(): string;
            metaType(): meta.MetaType;
            attributeTypeId(): number;
        }
        class MetaLiteral implements meta.KLiteral {
            private _name;
            private _index;
            private _className;
            constructor(p_name: string, p_index: number, p_className: string);
            index(): number;
            metaName(): string;
            metaType(): meta.MetaType;
            toString(): string;
        }
        class MetaModel implements meta.KMetaModel {
            private _name;
            private _index;
            private _metaClasses;
            private _metaClasses_indexes;
            private _metaTypes;
            private _metaTypes_indexes;
            index(): number;
            metaName(): string;
            metaType(): meta.MetaType;
            constructor(p_name: string);
            init(p_metaClasses: meta.KMetaClass[], p_metaEnums: meta.KMetaEnum[]): void;
            metaClasses(): meta.KMetaClass[];
            metaClassByName(name: string): meta.KMetaClass;
            metaClass(index: number): meta.KMetaClass;
            addMetaClass(metaClassName: string): meta.KMetaClass;
            addInferMetaClass(metaClassName: string, inferAlg: infer.KInferAlg): meta.KMetaClass;
            metaTypes(): meta.KMetaEnum[];
            metaTypeByName(p_name: string): meta.KMetaEnum;
            addMetaEnum(enumName: string): meta.KMetaEnum;
            private internal_addmetaclass(metaClassName, alg);
            private internal_add_meta_class(p_newMetaClass);
            private internal_add_type(p_newType);
            createModel(p_manager: memory.manager.internal.KInternalDataManager): KModel<any>;
        }
        class MetaOperation implements meta.KMetaOperation {
            private _name;
            private _index;
            private _originMetaClassIndex;
            private _paramTypes;
            private _paramIsArray;
            private _returnType;
            private _returnIsArray;
            index(): number;
            metaName(): string;
            metaType(): meta.MetaType;
            originMetaClassIndex(): number;
            paramTypes(): Int32Array;
            paramMultiplicities(): boolean[];
            returnType(): number;
            returnTypeIsArray(): boolean;
            constructor(p_name: string, p_index: number, p_originMetaClassIndex: number, p_paramTypes: Int32Array, p_returnType: number, p_paramIsArray: boolean[], p_returnIsArray: boolean);
            addParam(type: KType, isArray: boolean): void;
            setReturnType(type: KType, isArray: boolean): void;
        }
        class MetaRelation implements meta.KMetaRelation {
            private _name;
            private _index;
            private _visible;
            private _referredMetaClassIndex;
            private _op_name;
            private _originMetaClassIndex;
            private _maxBound;
            referredMetaClassIndex(): number;
            oppositeName(): string;
            originMetaClassIndex(): number;
            index(): number;
            metaName(): string;
            metaType(): meta.MetaType;
            visible(): boolean;
            maxBound(): number;
            setMaxBound(p_maxBound: number): void;
            constructor(p_name: string, p_index: number, p_visible: boolean, p_referredMetaClassIndex: number, op_name: string, p_originMetaClassIndex: number, p_maxBound: number);
        }
    }
}
export declare namespace operation {
    interface KOperationManager {
        register(operation: meta.KMetaOperation, callback: KOperation<any, any>): void;
        invoke(source: KObject, operation: meta.KMetaOperation, param: any[], strategy: operation.KOperationStrategy, callback: KCallback<any>): void;
        dispatch(message: message.KMessage): void;
        mappings(): string[];
    }
    interface KOperationStrategy {
        (cdn: cdn.KContentDeliveryDriver, metaOperation: meta.KMetaOperation, source: KObject, param: any[], manager: operation.KOperationManager, callback: KCallback<any>, additionalClassNames: string[]): void;
    }
    class OperationStrategies {
        static ONLY_ONE: operation.KOperationStrategy;
        static serialize(type: number, elem: any, isArray: boolean): string;
        static serializeParam(metaOperation: meta.KMetaOperation, param: any[]): string[];
        static serializeReturn(metaOperation: meta.KMetaOperation, result: any): string;
        static unserialize(metaModel: meta.KMetaModel, type: number, payload: string, isArray: boolean): any;
        static unserializeReturn(metaModel: meta.KMetaModel, metaOperation: meta.KMetaOperation, resultString: string): any;
        static unserializeParam(metaModel: meta.KMetaModel, metaOperation: meta.KMetaOperation, param: string[]): any[];
        static NAMED_PEER(peerName: string): operation.KOperationStrategy;
    }
    namespace impl {
        class HashOperationManager implements operation.KOperationManager {
            private staticOperations;
            private _manager;
            constructor(p_manager: memory.manager.internal.KInternalDataManager);
            register(operation: meta.KMetaOperation, callback: KOperation<any, any>): void;
            invoke(source: KObject, operation: meta.KMetaOperation, param: any[], strategy: operation.KOperationStrategy, callback: KCallback<any>): void;
            dispatch(m: message.KMessage): void;
            mappings(): string[];
        }
    }
}
export declare namespace scheduler {
    interface KScheduler {
        dispatch(task: scheduler.KTask): void;
        start(): void;
        stop(): void;
    }
    interface KTask {
        (): void;
    }
    namespace impl {
        class AsyncScheduler implements scheduler.KScheduler, java.lang.Runnable {
            dispatch: (task: KTask) => void;
            start: () => void;
            stop: () => void;
            run: () => void;
        }
        class DirectScheduler implements scheduler.KScheduler {
            dispatch(task: scheduler.KTask): void;
            start(): void;
            stop(): void;
        }
    }
}
export declare namespace traversal {
    interface KTraversal {
        traverse(metaReference: meta.KMetaRelation): traversal.KTraversal;
        traverseQuery(metaReferenceQuery: string): traversal.KTraversal;
        attributeQuery(attributeQuery: string): traversal.KTraversal;
        withAttribute(attribute: meta.KMetaAttribute, expectedValue: any): traversal.KTraversal;
        withoutAttribute(attribute: meta.KMetaAttribute, expectedValue: any): traversal.KTraversal;
        filter(filter: traversal.KTraversalFilter): traversal.KTraversal;
        then(cb: KCallback<KObject[]>): void;
        eval(expression: string, callback: KCallback<any[]>): void;
        map(attribute: meta.KMetaAttribute, cb: KCallback<any[]>): void;
        collect(metaReference: meta.KMetaRelation, continueCondition: traversal.KTraversalFilter): traversal.KTraversal;
        traverseTime(timeOffset: number, steps: number, continueCondition: traversal.KTraversalFilter): traversal.KTraversal;
        traverseUniverse(universeOffset: number, continueCondition: traversal.KTraversalFilter): traversal.KTraversal;
        traverseIndex(indexName: string, attributes: string): traversal.KTraversal;
        exec(origins: KObject[], view: KView, callback: KCallback<any[]>): void;
    }
    interface KTraversalAction {
        chain(next: traversal.KTraversalAction): void;
        execute(context: traversal.KTraversalActionContext): void;
    }
    interface KTraversalActionContext {
        inputObjects(): KObject[];
        setInputObjects(newSet: KObject[]): void;
        finalCallback(): KCallback<any[]>;
        baseView(): KView;
    }
    interface KTraversalFilter {
        (obj: KObject): boolean;
    }
    namespace impl {
        class Traversal implements traversal.KTraversal {
            private static TERMINATED_MESSAGE;
            private _initObjs;
            private _initAction;
            private _lastAction;
            private _terminated;
            constructor(p_roots: KObject[]);
            private internal_chain_action(p_action);
            traverse(p_metaReference: meta.KMetaRelation): traversal.KTraversal;
            traverseQuery(p_metaReferenceQuery: string): traversal.KTraversal;
            withAttribute(p_attribute: meta.KMetaAttribute, p_expectedValue: any): traversal.KTraversal;
            withoutAttribute(p_attribute: meta.KMetaAttribute, p_expectedValue: any): traversal.KTraversal;
            attributeQuery(p_attributeQuery: string): traversal.KTraversal;
            filter(p_filter: traversal.KTraversalFilter): traversal.KTraversal;
            collect(metaReference: meta.KMetaRelation, continueCondition: traversal.KTraversalFilter): traversal.KTraversal;
            traverseIndex(p_indexName: string, p_attributes: string): traversal.KTraversal;
            traverseTime(timeOffset: number, steps: number, continueCondition: traversal.KTraversalFilter): traversal.KTraversal;
            traverseUniverse(universeOffset: number, continueCondition: traversal.KTraversalFilter): traversal.KTraversal;
            then(cb: KCallback<KObject[]>): void;
            eval(p_expression: string, callback: KCallback<any[]>): void;
            map(attribute: meta.KMetaAttribute, cb: KCallback<any[]>): void;
            exec(origins: KObject[], review: KView, callback: KCallback<any[]>): void;
        }
        class TraversalContext implements traversal.KTraversalActionContext {
            private _inputs;
            private _view;
            private _finalCallback;
            constructor(p_inputs: KObject[], p_view: KView, p_finalCallback: KCallback<any[]>);
            inputObjects(): KObject[];
            setInputObjects(p_newSet: KObject[]): void;
            baseView(): KView;
            finalCallback(): KCallback<any[]>;
        }
        namespace actions {
            class DeepCollectAction implements traversal.KTraversalAction {
                private _next;
                private _reference;
                private _continueCondition;
                private _alreadyPassed;
                private _finalElements;
                constructor(p_reference: meta.KMetaRelation, p_continueCondition: traversal.KTraversalFilter);
                chain(p_next: traversal.KTraversalAction): void;
                execute(context: traversal.KTraversalActionContext): void;
                private executeStep(p_inputStep, private_callback);
            }
            class FilterAction implements traversal.KTraversalAction {
                private _next;
                private _filter;
                constructor(p_filter: traversal.KTraversalFilter);
                chain(p_next: traversal.KTraversalAction): void;
                execute(context: traversal.KTraversalActionContext): void;
            }
            class FilterAttributeAction implements traversal.KTraversalAction {
                private _next;
                private _attribute;
                private _expectedValue;
                constructor(p_attribute: meta.KMetaAttribute, p_expectedValue: any);
                chain(p_next: traversal.KTraversalAction): void;
                execute(context: traversal.KTraversalActionContext): void;
            }
            class FilterAttributeQueryAction implements traversal.KTraversalAction {
                private _next;
                private _attributeQuery;
                constructor(p_attributeQuery: string);
                chain(p_next: traversal.KTraversalAction): void;
                execute(context: traversal.KTraversalActionContext): void;
                private buildParams(p_paramString);
            }
            namespace FilterAttributeQueryAction {
                class QueryParam {
                    private _name;
                    private _value;
                    private _negative;
                    constructor(p_name: string, p_value: string, p_negative: boolean);
                    name(): string;
                    value(): string;
                    isNegative(): boolean;
                }
            }
            class FilterNotAttributeAction implements traversal.KTraversalAction {
                private _next;
                private _attribute;
                private _expectedValue;
                constructor(p_attribute: meta.KMetaAttribute, p_expectedValue: any);
                chain(p_next: traversal.KTraversalAction): void;
                execute(context: traversal.KTraversalActionContext): void;
            }
            class MapAction implements traversal.KTraversalAction {
                private _attribute;
                constructor(p_attribute: meta.KMetaAttribute);
                chain(next: traversal.KTraversalAction): void;
                execute(context: traversal.KTraversalActionContext): void;
            }
            class MathExpressionAction implements traversal.KTraversalAction {
                private _expression;
                private _engine;
                constructor(p_expression: string);
                chain(next: traversal.KTraversalAction): void;
                execute(context: traversal.KTraversalActionContext): void;
            }
            class RemoveDuplicateAction implements traversal.KTraversalAction {
                private _next;
                chain(p_next: traversal.KTraversalAction): void;
                execute(context: traversal.KTraversalActionContext): void;
            }
            class TraverseAction implements traversal.KTraversalAction {
                private _next;
                private _reference;
                constructor(p_reference: meta.KMetaRelation);
                chain(p_next: traversal.KTraversalAction): void;
                execute(context: traversal.KTraversalActionContext): void;
            }
            class TraverseIndexAction implements traversal.KTraversalAction {
                private _next;
                private _indexName;
                private _attributes;
                constructor(p_indexName: string, p_attributes: string);
                chain(p_next: traversal.KTraversalAction): void;
                execute(context: traversal.KTraversalActionContext): void;
            }
            class TraverseQueryAction implements traversal.KTraversalAction {
                private SEP;
                private _next;
                private _referenceQuery;
                constructor(p_referenceQuery: string);
                chain(p_next: traversal.KTraversalAction): void;
                execute(context: traversal.KTraversalActionContext): void;
            }
            class TraverseTimeAction implements traversal.KTraversalAction {
                private _next;
                private _timeOffset;
                private _steps;
                private _continueContition;
                constructor(p_timeOffset: number, p_steps: number, p_continueCondition: traversal.KTraversalFilter);
                chain(p_next: traversal.KTraversalAction): void;
                execute(context: traversal.KTraversalActionContext): void;
            }
        }
    }
    namespace query {
        interface KQueryEngine {
            eval(query: string, origins: KObject[], view: KView, callback: KCallback<any[]>): void;
            buildTraversal(query: string): traversal.KTraversal;
        }
        namespace impl {
            class QueryEngine implements traversal.query.KQueryEngine {
                private static INSTANCE;
                static OPEN_BRACKET: string;
                static CLOSE_BRACKET: string;
                static PIPE_SEP: string;
                static VAL_SEP: string;
                static VALS_SEP: string;
                static getINSTANCE(): traversal.query.KQueryEngine;
                eval(query: string, origins: KObject[], p_view: KView, callback: KCallback<any[]>): void;
                buildTraversal(query: string): traversal.KTraversal;
            }
        }
    }
    namespace visitor {
        interface KModelAttributeVisitor {
            (metaAttribute: meta.KMetaAttribute, value: any): void;
        }
        interface KModelVisitor {
            (elem: KObject): traversal.visitor.KVisitResult;
        }
        class KVisitResult {
            static CONTINUE: KVisitResult;
            static SKIP: KVisitResult;
            static STOP: KVisitResult;
            equals(other: any): boolean;
            static _KVisitResultVALUES: KVisitResult[];
            static values(): KVisitResult[];
        }
    }
}
export declare namespace util {
    class Base64 {
        private static encodeArray;
        private static decodeArray;
        private static powTwo;
        static encodeLong(l: number): string;
        static encodeLongToBuffer(l: number, buffer: java.lang.StringBuilder): void;
        static encodeInt(l: number): string;
        static encodeIntToBuffer(l: number, buffer: java.lang.StringBuilder): void;
        static decodeToLong(s: any): number;
        static decodeToLongWithBounds(s: string, offsetBegin: number, offsetEnd: number): number;
        static decodeToInt(s: any): number;
        static decodeToIntWithBounds(s: string, offsetBegin: number, offsetEnd: number): number;
        static encodeDouble(d: number): string;
        static encodeDoubleToBuffer(d: number, buffer: java.lang.StringBuilder): void;
        static decodeToDouble(s: string): number;
        static decodeToDoubleWithBounds(s: string, offsetBegin: number, offsetEnd: number): number;
        static encodeBoolArray(boolArr: Array<boolean>): string;
        static encodeBoolArrayToBuffer(boolArr: Array<boolean>, buffer: java.lang.StringBuilder): void;
        static decodeBoolArray(s: string, arraySize: number): any[];
        static decodeToBoolArrayWithBounds(s: string, offsetBegin: number, offsetEnd: number, arraySize: number): any[];
        static encodeString(s: string): string;
        static encodeStringToBuffer(s: string, buffer: java.lang.StringBuilder): void;
        static decodeString(s: string): string;
        static decodeToStringWithBounds(s: string, offsetBegin: number, offsetEnd: number): string;
    }
    class Checker {
        static isDefined(param: any): boolean;
    }
    class PrimitiveHelper {
        static startsWith(src: string, prefix: string): boolean;
        static endsWith(src: string, prefix: string): boolean;
        static matches(src: string, regex: string): boolean;
        static equals(src: string, other: string): boolean;
        static parseInt(val: string): number;
        static parseLong(val: string): number;
        static parseDouble(val: string): number;
        static parseShort(val: string): number;
        static parseBoolean(val: string): boolean;
        static SHORT_MIN_VALUE(): number;
        static SHORT_MAX_VALUE(): number;
        static isNaN(val: number): boolean;
        static DOUBLE_MIN_VALUE(): number;
        static DOUBLE_MAX_VALUE(): number;
        static stringHash(target: string): number;
    }
    namespace maths {
        class Correlations {
            static pearson(x: Float64Array, y: Float64Array): number;
        }
        class Distribution {
            static inverseNormalCDF(q: number): number;
            static gaussian(features: Float64Array, means: Float64Array, variances: Float64Array): number;
            static gaussianArray(features: util.maths.structure.KArray2D, row: number, means: Float64Array, variances: Float64Array): number;
            static parallelGaussian(features: Float64Array, means: Float64Array, variances: Float64Array): Float64Array;
            static gaussianOneFeature(feature: number, mean: number, variance: number): number;
        }
        class PolynomialFit {
            A: util.maths.matrix.DenseMatrix64F;
            coef: util.maths.matrix.DenseMatrix64F;
            y: util.maths.matrix.DenseMatrix64F;
            solver: util.maths.matrix.solvers.AdjLinearSolverQr;
            constructor(degree: number);
            getCoef(): Float64Array;
            fit(samplePoints: Float64Array, observations: Float64Array): void;
            static extrapolate(time: number, weights: Float64Array): number;
        }
        class Ranking {
            static wilsonRank(positive: number, negative: number, confidence: number): number;
        }
        class Statistic {
            static calcHistogram(data: Float64Array, dataratings: Float64Array, numBins: number): void;
        }
        class StringDistance {
            static levenshtein(s0: string, s1: string): number;
        }
        namespace expression {
            interface KMathExpressionEngine {
                parse(p_expression: string): util.maths.expression.KMathExpressionEngine;
                setVarResolver(resolver: util.maths.expression.KMathVariableResolver): void;
                eval(context: KObject): number;
            }
            interface KMathVariableResolver {
                (potentialVarName: string): number;
            }
            namespace impl {
                class MathDoubleToken implements util.maths.expression.impl.MathToken {
                    private _content;
                    type(): number;
                    constructor(_content: number);
                    content(): number;
                    type2(): number;
                }
                class MathEntities {
                    private static INSTANCE;
                    operators: memory.chunk.KStringMap<util.maths.expression.impl.MathOperation>;
                    functions: memory.chunk.KStringMap<util.maths.expression.impl.MathFunction>;
                    static getINSTANCE(): util.maths.expression.impl.MathEntities;
                    constructor();
                }
                class MathExpressionEngine implements util.maths.expression.KMathExpressionEngine {
                    private varResolver;
                    static decimalSeparator: string;
                    static minusSign: string;
                    private _cacheAST;
                    constructor();
                    static isNumber(st: string): boolean;
                    static isDigit(c: string): boolean;
                    static isLetter(c: string): boolean;
                    static isWhitespace(c: string): boolean;
                    private shuntingYard(expression);
                    eval(context: KObject): number;
                    buildAST(rpn: java.util.List<string>): util.maths.expression.impl.MathToken[];
                    parse(p_expression: string): util.maths.expression.KMathExpressionEngine;
                    setVarResolver(p_resolver: util.maths.expression.KMathVariableResolver): void;
                }
                class MathExpressionTokenizer {
                    private pos;
                    private input;
                    private previousToken;
                    constructor(input: string);
                    hasNext(): boolean;
                    private peekNextChar();
                    next(): string;
                    getPos(): number;
                }
                class MathFreeToken implements util.maths.expression.impl.MathToken {
                    private _content;
                    constructor(content: string);
                    content(): string;
                    type(): number;
                    type2(): number;
                }
                class MathFunction implements util.maths.expression.impl.MathToken {
                    private name;
                    private numParams;
                    constructor(name: string, numParams: number);
                    getName(): string;
                    getNumParams(): number;
                    eval(p: Float64Array): number;
                    private date_to_seconds(value);
                    private date_to_minutes(value);
                    private date_to_hours(value);
                    private date_to_days(value);
                    private date_to_months(value);
                    private date_to_year(value);
                    private date_to_dayofweek(value);
                    type(): number;
                    type2(): number;
                }
                class MathOperation implements util.maths.expression.impl.MathToken {
                    private oper;
                    private precedence;
                    private leftAssoc;
                    constructor(oper: string, precedence: number, leftAssoc: boolean);
                    getOper(): string;
                    getPrecedence(): number;
                    isLeftAssoc(): boolean;
                    eval(v1: number, v2: number): number;
                    type(): number;
                    type2(): number;
                }
                interface MathToken {
                    type(): number;
                    type2(): number;
                }
            }
        }
        namespace matrix {
            class CommonOps {
                static BLOCK_WIDTH: number;
                static TRANSPOSE_SWITCH: number;
                static MULT_COLUMN_SWITCH: number;
                static EPS: number;
                static mult(a: util.maths.matrix.DenseMatrix64F, b: util.maths.matrix.DenseMatrix64F, c: util.maths.matrix.DenseMatrix64F): void;
                static memset(data: Float64Array, val: number): void;
                static multAddalpha(alpha: number, a: util.maths.matrix.DenseMatrix64F, b: util.maths.matrix.DenseMatrix64F, c: util.maths.matrix.DenseMatrix64F): void;
                static multAlphaBetaTransA(alpha: number, a: util.maths.matrix.DenseMatrix64F, b: util.maths.matrix.DenseMatrix64F, c: util.maths.matrix.DenseMatrix64F, beta: number): void;
                static multTransA(a: util.maths.matrix.DenseMatrix64F, b: util.maths.matrix.DenseMatrix64F, c: util.maths.matrix.DenseMatrix64F): void;
                static multTransB(a: util.maths.matrix.DenseMatrix64F, b: util.maths.matrix.DenseMatrix64F, c: util.maths.matrix.DenseMatrix64F): void;
                static subvector(A: util.maths.matrix.DenseMatrix64F, rowA: number, colA: number, length: number, row: boolean, offsetV: number, v: util.maths.matrix.DenseMatrix64F): void;
                static abs(matrix: util.maths.matrix.SimpleMatrix): util.maths.matrix.SimpleMatrix;
                static trace(a: util.maths.matrix.DenseMatrix64F): number;
                static transposeMatrix(A: util.maths.matrix.DenseMatrix64F, A_tran: util.maths.matrix.DenseMatrix64F): util.maths.matrix.DenseMatrix64F;
                static transpose(mat: util.maths.matrix.DenseMatrix64F): void;
                static det(mat: util.maths.matrix.DenseMatrix64F): number;
                static invert(mat: util.maths.matrix.DenseMatrix64F, result: util.maths.matrix.DenseMatrix64F): boolean;
                static copyMatrix(matA: util.maths.structure.KArray2D, ejmlmatA: util.maths.matrix.SimpleMatrix): void;
                static copyMatrixDense(matA: util.maths.structure.impl.NativeArray2D, ejmlmatA: util.maths.matrix.DenseMatrix64F): void;
                static extractImpl(src: util.maths.matrix.DenseMatrix64F, srcY0: number, srcX0: number, dst: util.maths.matrix.DenseMatrix64F, dstY0: number, dstX0: number, numRows: number, numCols: number): void;
                static extractInsert(src: util.maths.matrix.DenseMatrix64F, srcY0: number, srcY1: number, srcX0: number, srcX1: number, dst: util.maths.matrix.DenseMatrix64F, dstY0: number, dstX0: number): void;
                static insert(src: util.maths.matrix.DenseMatrix64F, dest: util.maths.matrix.DenseMatrix64F, destY0: number, destX0: number): void;
                static extract4Int(src: util.maths.matrix.DenseMatrix64F, srcY0: number, srcY1: number, srcX0: number, srcX1: number): util.maths.matrix.DenseMatrix64F;
                static columnsToVector(A: util.maths.matrix.DenseMatrix64F, v: util.maths.matrix.DenseMatrix64F[]): util.maths.matrix.DenseMatrix64F[];
                static rowsToVector(A: util.maths.matrix.DenseMatrix64F, v: util.maths.matrix.DenseMatrix64F[]): util.maths.matrix.DenseMatrix64F[];
                static setIdentity(mat: util.maths.matrix.DenseMatrix64F): void;
                static identity1D(width: number): util.maths.matrix.DenseMatrix64F;
                static identity(numRows: number, numCols: number): util.maths.matrix.DenseMatrix64F;
                static diag(diagEl: Float64Array): util.maths.matrix.DenseMatrix64F;
                static diagMatrix(ret: util.maths.matrix.DenseMatrix64F, width: number, diagEl: Float64Array): util.maths.matrix.DenseMatrix64F;
                static kron(A: util.maths.matrix.DenseMatrix64F, B: util.maths.matrix.DenseMatrix64F, C: util.maths.matrix.DenseMatrix64F): void;
                static extractDiag(src: util.maths.matrix.DenseMatrix64F, dst: util.maths.matrix.DenseMatrix64F): void;
                static extractRow(a: util.maths.matrix.DenseMatrix64F, row: number, out: util.maths.matrix.DenseMatrix64F): util.maths.matrix.DenseMatrix64F;
                static extractColumn(a: util.maths.matrix.DenseMatrix64F, column: number, out: util.maths.matrix.DenseMatrix64F): util.maths.matrix.DenseMatrix64F;
                static elementMax(a: util.maths.matrix.DenseMatrix64F): number;
                static elementMaxAbs(a: util.maths.matrix.DenseMatrix64F): number;
                static elementMult(a: util.maths.matrix.DenseMatrix64F, b: util.maths.matrix.DenseMatrix64F, c: util.maths.matrix.DenseMatrix64F): void;
                static elementSum(mat: util.maths.matrix.DenseMatrix64F): number;
                static addEquals(a: util.maths.matrix.DenseMatrix64F, b: util.maths.matrix.DenseMatrix64F): void;
                static addEqualsbeta(a: util.maths.matrix.DenseMatrix64F, beta: number, b: util.maths.matrix.DenseMatrix64F): void;
                static add(a: util.maths.matrix.DenseMatrix64F, b: util.maths.matrix.DenseMatrix64F, c: util.maths.matrix.DenseMatrix64F): void;
                static subtract3mat(a: util.maths.matrix.DenseMatrix64F, b: util.maths.matrix.DenseMatrix64F, c: util.maths.matrix.DenseMatrix64F): void;
                static scale(alpha: number, a: util.maths.matrix.DenseMatrix64F): void;
                static changeSign(a: util.maths.matrix.DenseMatrix64F): void;
                static fill(a: util.maths.matrix.DenseMatrix64F, value: number): void;
                static normalizeF(A: util.maths.matrix.DenseMatrix64F): void;
                static normF(a: util.maths.matrix.DenseMatrix64F): number;
                static extract6M(src: util.maths.matrix.DenseMatrix64F, srcY0: number, srcY1: number, srcX0: number, srcX1: number, dst: util.maths.matrix.DenseMatrix64F, dstY0: number, dstX0: number): void;
                static multAlphaBeta(alpha: number, matrix: util.maths.matrix.DenseMatrix64F, matrix1: util.maths.matrix.DenseMatrix64F, matrix2: util.maths.matrix.DenseMatrix64F, beta: number): void;
            }
            class Complex64F {
                real: number;
                imaginary: number;
                constructor();
                getReal(): number;
                getMagnitude(): number;
                getMagnitude2(): number;
                setReal(real: number): void;
                setValues(real: number, imaginary: number): void;
                isReal(): boolean;
                toString(): string;
                times(a: util.maths.matrix.Complex64F): util.maths.matrix.Complex64F;
            }
            class ComplexMath64F {
                static conj(input: util.maths.matrix.Complex64F, conj: util.maths.matrix.Complex64F): void;
                static plus(a: util.maths.matrix.Complex64F, b: util.maths.matrix.Complex64F, result: util.maths.matrix.Complex64F): void;
                static minus(a: util.maths.matrix.Complex64F, b: util.maths.matrix.Complex64F, result: util.maths.matrix.Complex64F): void;
                static multiply(a: util.maths.matrix.Complex64F, b: util.maths.matrix.Complex64F, result: util.maths.matrix.Complex64F): void;
                static divide(a: util.maths.matrix.Complex64F, b: util.maths.matrix.Complex64F, result: util.maths.matrix.Complex64F): void;
                static root(a: util.maths.matrix.Complex64F, N: number, k: number, result: util.maths.matrix.Complex64F): void;
                static sqrt(input: util.maths.matrix.Complex64F, root: util.maths.matrix.Complex64F): void;
            }
            class DenseMatrix64F {
                numRows: number;
                numCols: number;
                data: Float64Array;
                static MULT_COLUMN_SWITCH: number;
                constructor(numRows: number, numCols: number);
                constructorDenseMatrix(orig: util.maths.matrix.DenseMatrix64F): util.maths.matrix.DenseMatrix64F;
                static setIdentity(mat: util.maths.matrix.DenseMatrix64F): void;
                static widentity(width: number): util.maths.matrix.DenseMatrix64F;
                static identity(numRows: number, numCols: number): util.maths.matrix.DenseMatrix64F;
                zero(): void;
                copy(): util.maths.matrix.DenseMatrix64F;
                static fill(a: util.maths.matrix.DenseMatrix64F, value: number): void;
                reshapeBoolean(numRows: number, numCols: number, saveValues: boolean): void;
                cset(row: number, col: number, value: number): void;
                add(row: number, col: number, value: number): void;
                plus(index: number, val: number): number;
                scale(value: number): util.maths.matrix.DenseMatrix64F;
                minus(index: number, val: number): number;
                times(index: number, val: number): number;
                div(index: number, val: number): number;
                reshape(numRows: number, numCols: number): void;
                getNumRows(): number;
                getNumCols(): number;
                getData(): Float64Array;
                get(row: number, col: number): number;
                getNumElements(): number;
                getIndex(row: number, col: number): number;
                getValueAtIndex(index: number): number;
                setValueAtIndex(index: number, val: number): number;
                setNumRows(numRows: number): void;
                setNumCols(numCols: number): void;
                setData(data: Float64Array): void;
                setMatrix(b: util.maths.matrix.DenseMatrix64F): void;
                set(row: number, col: number, value: number): void;
            }
            class MatrixFeatures {
                static isVector(mat: util.maths.matrix.DenseMatrix64F): boolean;
                static isSymmetricDouble(m: util.maths.matrix.DenseMatrix64F, tol: number): boolean;
                static isIdentical(a: util.maths.matrix.DenseMatrix64F, b: util.maths.matrix.DenseMatrix64F, tol: number): boolean;
            }
            class MatrixMatrixMult {
                static multTransA_smallMV(A: util.maths.matrix.DenseMatrix64F, B: util.maths.matrix.DenseMatrix64F, C: util.maths.matrix.DenseMatrix64F): void;
                static multTransA_reorderMV(A: util.maths.matrix.DenseMatrix64F, B: util.maths.matrix.DenseMatrix64F, C: util.maths.matrix.DenseMatrix64F): void;
                static multTransA_reorderMM(a: util.maths.matrix.DenseMatrix64F, b: util.maths.matrix.DenseMatrix64F, c: util.maths.matrix.DenseMatrix64F): void;
                static multTransA_smallMM(a: util.maths.matrix.DenseMatrix64F, b: util.maths.matrix.DenseMatrix64F, c: util.maths.matrix.DenseMatrix64F): void;
                static multTransA(a: util.maths.matrix.DenseMatrix64F, b: util.maths.matrix.DenseMatrix64F, c: util.maths.matrix.DenseMatrix64F): void;
                static mult_reorder(a: util.maths.matrix.DenseMatrix64F, b: util.maths.matrix.DenseMatrix64F, c: util.maths.matrix.DenseMatrix64F): void;
                static mult_small(a: util.maths.matrix.DenseMatrix64F, b: util.maths.matrix.DenseMatrix64F, c: util.maths.matrix.DenseMatrix64F): void;
                static multTransA_reorder(a: util.maths.matrix.DenseMatrix64F, b: util.maths.matrix.DenseMatrix64F, c: util.maths.matrix.DenseMatrix64F): void;
                static multTransA_small(a: util.maths.matrix.DenseMatrix64F, b: util.maths.matrix.DenseMatrix64F, c: util.maths.matrix.DenseMatrix64F): void;
                static multTransB(a: util.maths.matrix.DenseMatrix64F, b: util.maths.matrix.DenseMatrix64F, c: util.maths.matrix.DenseMatrix64F): void;
                static multAlphaTransA_reorder(alpha: number, a: util.maths.matrix.DenseMatrix64F, b: util.maths.matrix.DenseMatrix64F, c: util.maths.matrix.DenseMatrix64F): void;
                static multAlphaTransA_small(alpha: number, a: util.maths.matrix.DenseMatrix64F, b: util.maths.matrix.DenseMatrix64F, c: util.maths.matrix.DenseMatrix64F): void;
                static multAdd_reorderalpha(alpha: number, a: util.maths.matrix.DenseMatrix64F, b: util.maths.matrix.DenseMatrix64F, c: util.maths.matrix.DenseMatrix64F): void;
                static multAdd_smallalpha(alpha: number, a: util.maths.matrix.DenseMatrix64F, b: util.maths.matrix.DenseMatrix64F, c: util.maths.matrix.DenseMatrix64F): void;
            }
            class MatrixVectorMult {
                static mult(A: util.maths.matrix.DenseMatrix64F, B: util.maths.matrix.DenseMatrix64F, C: util.maths.matrix.DenseMatrix64F): void;
                static multTransA_small(A: util.maths.matrix.DenseMatrix64F, B: util.maths.matrix.DenseMatrix64F, C: util.maths.matrix.DenseMatrix64F): void;
                static multTransA_reorder(A: util.maths.matrix.DenseMatrix64F, B: util.maths.matrix.DenseMatrix64F, C: util.maths.matrix.DenseMatrix64F): void;
            }
            class SimpleMatrix {
                mat: util.maths.matrix.DenseMatrix64F;
                getMatrix(): util.maths.matrix.DenseMatrix64F;
                setValue2D(row: number, col: number, value: number): void;
                setValue1D(index: number, value: number): void;
                getValue2D(row: number, col: number): number;
                getValue1D(index: number): number;
                getIndex(row: number, col: number): number;
                mult(b: util.maths.matrix.SimpleMatrix): util.maths.matrix.SimpleMatrix;
                scale(val: number): util.maths.matrix.SimpleMatrix;
                plus(b: util.maths.matrix.SimpleMatrix): util.maths.matrix.SimpleMatrix;
                copy(): util.maths.matrix.SimpleMatrix;
                numRows(): number;
                numCols(): number;
                getNumElements(): number;
                extractDiag(): util.maths.matrix.SimpleMatrix;
                isIdentical(a: util.maths.matrix.SimpleMatrix, tol: number): boolean;
                trace(): number;
                elementMaxAbs(): number;
                elementSum(): number;
                elementMult(b: util.maths.matrix.SimpleMatrix): util.maths.matrix.SimpleMatrix;
                isInBounds(row: number, col: number): boolean;
                printDimensions(): void;
                transpose(): util.maths.matrix.SimpleMatrix;
                constructor(numRows: number, numCols: number);
                static wrap(internalMat: util.maths.matrix.DenseMatrix64F): util.maths.matrix.SimpleMatrix;
                static identity(width: number): util.maths.matrix.SimpleMatrix;
                minus(b: util.maths.matrix.SimpleMatrix): util.maths.matrix.SimpleMatrix;
                invert(): util.maths.matrix.SimpleMatrix;
                determinant(): number;
                createMatrix(numRows: number, numCols: number): util.maths.matrix.SimpleMatrix;
                extractVector(extractRow: boolean, element: number): util.maths.matrix.SimpleMatrix;
                eig(): util.maths.matrix.solvers.SimpleEVD<any>;
                svd(compact: boolean): util.maths.matrix.solvers.SimpleSVD<any>;
                combine(insertRow: number, insertCol: number, B: util.maths.matrix.SimpleMatrix): util.maths.matrix.SimpleMatrix;
                insertIntoThis(insertRow: number, insertCol: number, B: util.maths.matrix.SimpleMatrix): void;
            }
            class TransposeAlgs {
                static square(mat: util.maths.matrix.DenseMatrix64F): void;
                static block(A: util.maths.matrix.DenseMatrix64F, A_tran: util.maths.matrix.DenseMatrix64F, blockLength: number): void;
                static standard(A: util.maths.matrix.DenseMatrix64F, A_tran: util.maths.matrix.DenseMatrix64F): void;
            }
            namespace solvers {
                class AdjLinearSolverQr {
                    numRows: number;
                    numCols: number;
                    private decomposer;
                    maxRows: number;
                    maxCols: number;
                    Q: util.maths.matrix.DenseMatrix64F;
                    R: util.maths.matrix.DenseMatrix64F;
                    private Y;
                    private Z;
                    setA(A: util.maths.matrix.DenseMatrix64F): boolean;
                    private solveU(U, b, n);
                    solve(B: util.maths.matrix.DenseMatrix64F, X: util.maths.matrix.DenseMatrix64F): void;
                    constructor();
                    setMaxSize(maxRows: number, maxCols: number): void;
                }
                class LUDecompositionAlt_D64 {
                    LU: util.maths.matrix.DenseMatrix64F;
                    maxWidth: number;
                    m: number;
                    n: number;
                    dataLU: Float64Array;
                    vv: Float64Array;
                    indx: Int32Array;
                    pivot: Int32Array;
                    pivsign: number;
                    setExpectedMaxSize(numRows: number, numCols: number): void;
                    getLU(): util.maths.matrix.DenseMatrix64F;
                    getIndx(): Int32Array;
                    getPivot(): Int32Array;
                    getLower(lower: util.maths.matrix.DenseMatrix64F): util.maths.matrix.DenseMatrix64F;
                    getUpper(upper: util.maths.matrix.DenseMatrix64F): util.maths.matrix.DenseMatrix64F;
                    decomposeCommonInit(a: util.maths.matrix.DenseMatrix64F): void;
                    _solveVectorInternal(vv: Float64Array): void;
                    _getVV(): Float64Array;
                    computeDeterminant(): number;
                    decompose(a: util.maths.matrix.DenseMatrix64F): boolean;
                }
                class LinearSolverLu_D64 {
                    A: util.maths.matrix.DenseMatrix64F;
                    numRows: number;
                    numCols: number;
                    decomp: util.maths.matrix.solvers.LUDecompositionAlt_D64;
                    doImprove: boolean;
                    getA(): util.maths.matrix.DenseMatrix64F;
                    _setA(A: util.maths.matrix.DenseMatrix64F): void;
                    constructor(decomp: util.maths.matrix.solvers.LUDecompositionAlt_D64);
                    setA(A: util.maths.matrix.DenseMatrix64F): boolean;
                    invert(A_inv: util.maths.matrix.DenseMatrix64F): void;
                    improveSol(b: util.maths.matrix.DenseMatrix64F, x: util.maths.matrix.DenseMatrix64F): void;
                    modifiesA(): boolean;
                    modifiesB(): boolean;
                    solve(b: util.maths.matrix.DenseMatrix64F, x: util.maths.matrix.DenseMatrix64F): void;
                }
                class SimpleEVD<T extends util.maths.matrix.SimpleMatrix> {
                    private eig;
                    mat: util.maths.matrix.DenseMatrix64F;
                    constructor(mat: util.maths.matrix.DenseMatrix64F);
                    getNumberOfEigenvalues(): number;
                    getEigenvalue(index: number): util.maths.matrix.Complex64F;
                    getEigenVector(index: number): T;
                    getEVD(): util.maths.matrix.solvers.decomposition.SwitchingEigenDecomposition;
                    getIndexMax(): number;
                    getIndexMin(): number;
                }
                class SimpleSVD<T extends util.maths.matrix.SimpleMatrix> {
                    private svd;
                    private U;
                    private W;
                    private V;
                    private mat;
                    tol: number;
                    private static swapRowOrCol(M, tran, i, bigIndex);
                    static singularThreshold(svd: util.maths.matrix.solvers.SvdImplicitQrDecompose_D64): number;
                    static descendingOrder(U: util.maths.matrix.DenseMatrix64F, tranU: boolean, W: util.maths.matrix.DenseMatrix64F, V: util.maths.matrix.DenseMatrix64F, tranV: boolean): void;
                    constructor(mat: util.maths.matrix.DenseMatrix64F, compact: boolean);
                    getU(): T;
                    getW(): T;
                    getV(): T;
                }
                class SvdImplicitQrAlgorithm {
                    rand: java.util.Random;
                    Ut: util.maths.matrix.DenseMatrix64F;
                    Vt: util.maths.matrix.DenseMatrix64F;
                    totalSteps: number;
                    maxValue: number;
                    N: number;
                    eigenSmall: util.maths.matrix.solvers.decomposition.EigenvalueSmall;
                    numExceptional: number;
                    nextExceptional: number;
                    diag: Float64Array;
                    off: Float64Array;
                    bulge: number;
                    x1: number;
                    x2: number;
                    steps: number;
                    splits: Int32Array;
                    numSplits: number;
                    private exceptionalThresh;
                    private maxIterations;
                    followScript: boolean;
                    private static giveUpOnKnown;
                    private values;
                    private fastValues;
                    private findingZeros;
                    c: number;
                    s: number;
                    constructor();
                    getUt(): util.maths.matrix.DenseMatrix64F;
                    setUt(ut: util.maths.matrix.DenseMatrix64F): void;
                    getVt(): util.maths.matrix.DenseMatrix64F;
                    setVt(vt: util.maths.matrix.DenseMatrix64F): void;
                    setMatrix(numRows: number, numCols: number, diag: Float64Array, off: Float64Array): void;
                    swapDiag(diag: Float64Array): Float64Array;
                    swapOff(off: Float64Array): Float64Array;
                    setMaxValue(maxValue: number): void;
                    initParam(M: number, N: number): void;
                    process(): boolean;
                    processValues(values: Float64Array): boolean;
                    _process(): boolean;
                    private performDynamicStep();
                    private performScriptedStep();
                    incrementSteps(): void;
                    isOffZero(i: number): boolean;
                    isDiagonalZero(i: number): boolean;
                    resetSteps(): void;
                    nextSplit(): boolean;
                    performImplicitSingleStep(scale: number, lambda: number, byAngle: boolean): void;
                    updateRotator(Q: util.maths.matrix.DenseMatrix64F, m: number, n: number, c: number, s: number): void;
                    private computeBulgeScale();
                    createBulge(x1: number, p: number, scale: number, byAngle: boolean): void;
                    computeRotator(rise: number, run: number): void;
                    removeBulgeLeft(x1: number, notLast: boolean): void;
                    removeBulgeRight(x1: number): void;
                    setSubmatrix(x1: number, x2: number): void;
                    selectWilkinsonShift(scale: number): number;
                    static signum(d: number): number;
                    eigenBB_2x2(x1: number): void;
                    checkForAndHandleZeros(): boolean;
                    private pushRight(row);
                    private rotatorPushRight(m);
                    private rotatorPushRight2(m, offset);
                    exceptionShift(): void;
                    getNumberOfSingularValues(): number;
                    getSingularValue(index: number): number;
                    setFastValues(b: boolean): void;
                    getSingularValues(): Float64Array;
                    getDiag(): Float64Array;
                    getOff(): Float64Array;
                    getMaxValue(): number;
                }
                class SvdImplicitQrDecompose_D64 {
                    private numRows;
                    private numCols;
                    private numRowsT;
                    private numColsT;
                    private canUseTallBidiagonal;
                    private bidiag;
                    private qralg;
                    diag: Float64Array;
                    off: Float64Array;
                    private Ut;
                    private Vt;
                    private singularValues;
                    private numSingular;
                    private compact;
                    private computeU;
                    private computeV;
                    private prefComputeU;
                    private prefComputeV;
                    private transposed;
                    private A_mod;
                    constructor(compact: boolean, computeU: boolean, computeV: boolean, canUseTallBidiagonal: boolean);
                    getSingularValues(): Float64Array;
                    numberOfSingularValues(): number;
                    isCompact(): boolean;
                    getU(U: util.maths.matrix.DenseMatrix64F, transpose: boolean): util.maths.matrix.DenseMatrix64F;
                    getV(V: util.maths.matrix.DenseMatrix64F, transpose: boolean): util.maths.matrix.DenseMatrix64F;
                    getW(W: util.maths.matrix.DenseMatrix64F): util.maths.matrix.DenseMatrix64F;
                    decompose(orig: util.maths.matrix.DenseMatrix64F): boolean;
                    inputModified(): boolean;
                    private bidiagonalization(orig);
                    private undoTranspose();
                    private computeUWV();
                    private setup(orig);
                    private makeSingularPositive();
                    getNumRows(): number;
                    getNumCols(): number;
                }
                class TriangularSolver {
                    static solveU2arr(U: Float64Array, b: Float64Array, n: number): void;
                    static solveU(U: Float64Array, b: Float64Array, sideLength: number, minRow: number, maxRow: number): void;
                }
                namespace decomposition {
                    interface BidiagonalDecomposition<T extends util.maths.matrix.DenseMatrix64F> {
                        getB(B: T, compact: boolean): T;
                        getU(U: T, transpose: boolean, compact: boolean): T;
                        getV(V: T, transpose: boolean, compact: boolean): T;
                        getDiagonal(diag: Float64Array, off: Float64Array): void;
                        decompose(orig: T): boolean;
                        inputModified(): boolean;
                    }
                    class BidiagonalDecompositionRow_D64 implements util.maths.matrix.solvers.decomposition.BidiagonalDecomposition<util.maths.matrix.DenseMatrix64F> {
                        private UBV;
                        private m;
                        private n;
                        private min;
                        private gammasU;
                        private gammasV;
                        private b;
                        private u;
                        constructor(numElements: number);
                        decompose(A: util.maths.matrix.DenseMatrix64F): boolean;
                        init(A: util.maths.matrix.DenseMatrix64F): void;
                        getUBV(): util.maths.matrix.DenseMatrix64F;
                        getDiagonal(diag: Float64Array, off: Float64Array): void;
                        getB(B: util.maths.matrix.DenseMatrix64F, compact: boolean): util.maths.matrix.DenseMatrix64F;
                        static handleB(B: util.maths.matrix.DenseMatrix64F, compact: boolean, m: number, n: number, min: number): util.maths.matrix.DenseMatrix64F;
                        getU(U: util.maths.matrix.DenseMatrix64F, transpose: boolean, compact: boolean): util.maths.matrix.DenseMatrix64F;
                        static handleU(U: util.maths.matrix.DenseMatrix64F, transpose: boolean, compact: boolean, m: number, n: number, min: number): util.maths.matrix.DenseMatrix64F;
                        getV(V: util.maths.matrix.DenseMatrix64F, transpose: boolean, compact: boolean): util.maths.matrix.DenseMatrix64F;
                        static handleV(V: util.maths.matrix.DenseMatrix64F, transpose: boolean, compact: boolean, m: number, n: number, min: number): util.maths.matrix.DenseMatrix64F;
                        private _decompose();
                        computeU(k: number): void;
                        computeV(k: number): void;
                        getGammasU(): Float64Array;
                        getGammasV(): Float64Array;
                        inputModified(): boolean;
                    }
                    class BidiagonalDecompositionTall_D64 implements util.maths.matrix.solvers.decomposition.BidiagonalDecomposition<util.maths.matrix.DenseMatrix64F> {
                        decompQRP: util.maths.matrix.solvers.decomposition.QRxColPivDecompositionHouseholderColumn_D64;
                        decompBi: util.maths.matrix.solvers.decomposition.BidiagonalDecomposition<util.maths.matrix.DenseMatrix64F>;
                        B: util.maths.matrix.DenseMatrix64F;
                        m: number;
                        n: number;
                        min: number;
                        getDiagonal(diag: Float64Array, off: Float64Array): void;
                        getB(B: util.maths.matrix.DenseMatrix64F, compact: boolean): util.maths.matrix.DenseMatrix64F;
                        getU(U: util.maths.matrix.DenseMatrix64F, transpose: boolean, compact: boolean): util.maths.matrix.DenseMatrix64F;
                        getV(V: util.maths.matrix.DenseMatrix64F, transpose: boolean, compact: boolean): util.maths.matrix.DenseMatrix64F;
                        decompose(orig: util.maths.matrix.DenseMatrix64F): boolean;
                        inputModified(): boolean;
                    }
                    class EigenvalueSmall {
                        value0: util.maths.matrix.Complex64F;
                        value1: util.maths.matrix.Complex64F;
                        value2x2(a11: number, a12: number, a21: number, a22: number): void;
                        value2x2_fast(a11: number, a12: number, a21: number, a22: number): void;
                        symm2x2_fast(a11: number, a12: number, a22: number): void;
                    }
                    class HessenbergSimilarDecomposition_D64 {
                        private QH;
                        private N;
                        private gammas;
                        private b;
                        private u;
                        constructor(initialSize: number);
                        decompose(A: util.maths.matrix.DenseMatrix64F): boolean;
                        inputModified(): boolean;
                        getQH(): util.maths.matrix.DenseMatrix64F;
                        getH(H: util.maths.matrix.DenseMatrix64F): util.maths.matrix.DenseMatrix64F;
                        getQ(Q: util.maths.matrix.DenseMatrix64F): util.maths.matrix.DenseMatrix64F;
                        private _decompose();
                        getGammas(): Float64Array;
                    }
                    class QRDecompositionHouseholderColumn_D64 {
                        dataQR: util.maths.structure.KArray2D;
                        v: Float64Array;
                        numCols: number;
                        numRows: number;
                        minLength: number;
                        gammas: Float64Array;
                        gamma: number;
                        tau: number;
                        error: boolean;
                        setExpectedMaxSize(numRows: number, numCols: number): void;
                        getQ(Q: util.maths.matrix.DenseMatrix64F, compact: boolean): util.maths.matrix.DenseMatrix64F;
                        getR(R: util.maths.matrix.DenseMatrix64F, compact: boolean): util.maths.matrix.DenseMatrix64F;
                        decompose(A: util.maths.matrix.DenseMatrix64F): boolean;
                        convertToColumnMajor(A: util.maths.matrix.DenseMatrix64F): void;
                        householder(j: number): void;
                        updateA(w: number): void;
                        static findMax(u: util.maths.structure.KArray2D, col: number, startU: number, length: number): number;
                        static divideElements(j: number, numRows: number, u: util.maths.structure.KArray2D, col: number, u_0: number): void;
                        static computeTauAndDivide(j: number, numRows: number, u: util.maths.structure.KArray2D, col: number, max: number): number;
                        inputModified(): boolean;
                        static rank1UpdateMultR(A: util.maths.matrix.DenseMatrix64F, u: util.maths.structure.KArray2D, col: number, gamma: number, colA0: number, w0: number, w1: number, _temp: Float64Array): void;
                    }
                    class QRxColPivDecompositionHouseholderColumn_D64 extends util.maths.matrix.solvers.decomposition.QRDecompositionHouseholderColumn_D64 {
                        pivots: Int32Array;
                        normsCol: Float64Array;
                        maxAbs: number;
                        singularThreshold: number;
                        rank: number;
                        constructor();
                        setSingularThreshold(threshold: number): void;
                        setExpectedMaxSize(numRows: number, numCols: number): void;
                        getQ(Q: util.maths.matrix.DenseMatrix64F, compact: boolean): util.maths.matrix.DenseMatrix64F;
                        decompose(A: util.maths.matrix.DenseMatrix64F): boolean;
                        private setupPivotInfo();
                        private updateNorms(j);
                        private swapColumns(j);
                        householderPivot(j: number): boolean;
                        getRank(): number;
                        getPivots(): Int32Array;
                        getPivotMatrix(P: util.maths.matrix.DenseMatrix64F): util.maths.matrix.DenseMatrix64F;
                    }
                    class QrHelperFunctions_D64 {
                        static findMax(u: Float64Array, startU: number, length: number): number;
                        static findMaxArray(u: util.maths.structure.KArray2D, col: number, startU: number, length: number): number;
                        static divideElements4arg(j: number, numRows: number, u: Float64Array, u_0: number): void;
                        static divideElements4argArray(j: number, numRows: number, u: util.maths.structure.KArray2D, col: number, u_0: number): void;
                        static divideElements(j: number, numRows: number, u: Float64Array, startU: number, u_0: number): void;
                        static divideElements_Brow(j: number, numRows: number, u: Float64Array, b: Float64Array, startB: number, u_0: number): void;
                        static divideElements_Bcol(j: number, numRows: number, numCols: number, u: Float64Array, b: Float64Array, startB: number, u_0: number): void;
                        static computeTauAndDivide(j: number, numRows: number, u: Float64Array, startU: number, max: number): number;
                        static computeTauAndDivide4arg(j: number, numRows: number, u: Float64Array, max: number): number;
                        static computeTauAndDivide4argArray(j: number, numRows: number, u: util.maths.structure.KArray2D, col: number, max: number): number;
                        static rank1UpdateMultR(A: util.maths.matrix.DenseMatrix64F, u: Float64Array, gamma: number, colA0: number, w0: number, w1: number, _temp: Float64Array): void;
                        static rank1UpdateMultRArray(A: util.maths.matrix.DenseMatrix64F, u: util.maths.structure.KArray2D, col: number, gamma: number, colA0: number, w0: number, w1: number, _temp: Float64Array): void;
                        static rank1UpdateMultR8param(A: util.maths.matrix.DenseMatrix64F, u: Float64Array, offsetU: number, gamma: number, colA0: number, w0: number, w1: number, _temp: Float64Array): void;
                        static rank1UpdateMultL(A: util.maths.matrix.DenseMatrix64F, u: Float64Array, gamma: number, colA0: number, w0: number, w1: number): void;
                    }
                    class SwitchingEigenDecomposition {
                        private tol;
                        symmetricAlg: util.maths.matrix.solvers.decomposition.SymmetricQRAlgorithmDecomposition_D64;
                        generalAlg: util.maths.matrix.solvers.decomposition.WatchedDoubleStepQRDecomposition_D64;
                        symmetric: boolean;
                        computeVectors: boolean;
                        A: util.maths.matrix.DenseMatrix64F;
                        constructor(matrixSize: number, computeVectors: boolean, tol: number);
                        getNumberOfEigenvalues(): number;
                        getEigenvalue(index: number): util.maths.matrix.Complex64F;
                        getEigenVector(index: number): util.maths.matrix.DenseMatrix64F;
                        decompose(orig: util.maths.matrix.DenseMatrix64F): boolean;
                        inputModified(): boolean;
                    }
                    class SymmetricQRAlgorithmDecomposition_D64 {
                        private decomp;
                        private helper;
                        private vector;
                        private computeVectorsWithValues;
                        private values;
                        private diag;
                        private off;
                        private diagSaved;
                        private offSaved;
                        private V;
                        private eigenvectors;
                        computeVectors: boolean;
                        constructor(decomp: util.maths.matrix.solvers.decomposition.TridiagonalDecompositionHouseholder_D64, computeVectors: boolean);
                        setComputeVectorsWithValues(computeVectorsWithValues: boolean): void;
                        setMaxIterations(max: number): void;
                        getNumberOfEigenvalues(): number;
                        getEigenvalue(index: number): util.maths.matrix.Complex64F;
                        getEigenVector(index: number): util.maths.matrix.DenseMatrix64F;
                        decompose(orig: util.maths.matrix.DenseMatrix64F): boolean;
                        inputModified(): boolean;
                        private extractTogether();
                        private extractSeparate(numCols);
                        private computeEigenValues();
                    }
                    class SymmetricQREigenHelper {
                        rand: java.util.Random;
                        steps: number;
                        numExceptional: number;
                        lastExceptional: number;
                        eigenSmall: util.maths.matrix.solvers.decomposition.EigenvalueSmall;
                        Q: util.maths.matrix.DenseMatrix64F;
                        N: number;
                        diag: Float64Array;
                        off: Float64Array;
                        x1: number;
                        x2: number;
                        splits: Int32Array;
                        numSplits: number;
                        private bulge;
                        private c;
                        private s;
                        private c2;
                        private s2;
                        private cs;
                        constructor();
                        setQ(q: util.maths.matrix.DenseMatrix64F): void;
                        incrementSteps(): void;
                        init(diag: Float64Array, off: Float64Array, numCols: number): void;
                        swapDiag(diag: Float64Array): Float64Array;
                        swapOff(off: Float64Array): Float64Array;
                        reset(N: number): void;
                        copyDiag(ret: Float64Array): Float64Array;
                        copyOff(ret: Float64Array): Float64Array;
                        copyEigenvalues(ret: Float64Array): Float64Array;
                        setSubmatrix(x1: number, x2: number): void;
                        isZero(index: number): boolean;
                        performImplicitSingleStep(lambda: number, byAngle: boolean): void;
                        updateQ(m: number, n: number, c: number, s: number): void;
                        createBulge(x1: number, p: number, byAngle: boolean): void;
                        createBulge2by2(x1: number, p: number, byAngle: boolean): void;
                        private computeRotation(run, rise);
                        removeBulge(x1: number): void;
                        removeBulgeEnd(x1: number): void;
                        eigenvalue2by2(x1: number): void;
                        exceptionalShift(): void;
                        nextSplit(): boolean;
                        computeShift(): number;
                        computeWilkinsonShift(): number;
                        getMatrixSize(): number;
                        resetSteps(): void;
                    }
                    class SymmetricQrAlgorithm {
                        private helper;
                        private Q;
                        private eigenvalues;
                        private exceptionalThresh;
                        private maxIterations;
                        private fastEigenvalues;
                        private followingScript;
                        constructor(helper: util.maths.matrix.solvers.decomposition.SymmetricQREigenHelper);
                        setMaxIterations(maxIterations: number): void;
                        getQ(): util.maths.matrix.DenseMatrix64F;
                        setQ(q: util.maths.matrix.DenseMatrix64F): void;
                        setFastEigenvalues(fastEigenvalues: boolean): void;
                        getEigenvalue(index: number): number;
                        getNumberOfEigenvalues(): number;
                        process(sideLength: number, diag: Float64Array, off: Float64Array, eigenvalues: Float64Array): boolean;
                        process3arg(sideLength: number, diag: Float64Array, off: Float64Array): boolean;
                        private _process();
                        performStep(): void;
                    }
                    class TridiagonalDecompositionHouseholder_D64 {
                        private QT;
                        private N;
                        private w;
                        private gammas;
                        private b;
                        constructor();
                        getQT(): util.maths.matrix.DenseMatrix64F;
                        getDiagonal(diag: Float64Array, off: Float64Array): void;
                        getT(T: util.maths.matrix.DenseMatrix64F): util.maths.matrix.DenseMatrix64F;
                        getQ(Q: util.maths.matrix.DenseMatrix64F, transposed: boolean): util.maths.matrix.DenseMatrix64F;
                        decompose(A: util.maths.matrix.DenseMatrix64F): boolean;
                        private similarTransform(k);
                        householderSymmetric(row: number, gamma: number): void;
                        init(A: util.maths.matrix.DenseMatrix64F): void;
                        inputModified(): boolean;
                    }
                    class WatchedDoubleStepQRDecomposition_D64 {
                        hessenberg: util.maths.matrix.solvers.decomposition.HessenbergSimilarDecomposition_D64;
                        algValue: util.maths.matrix.solvers.decomposition.WatchedDoubleStepQREigenvalue;
                        algVector: util.maths.matrix.solvers.decomposition.WatchedDoubleStepQREigenvector;
                        H: util.maths.matrix.DenseMatrix64F;
                        computeVectors: boolean;
                        constructor(computeVectors: boolean);
                        decompose(A: util.maths.matrix.DenseMatrix64F): boolean;
                        inputModified(): boolean;
                        getNumberOfEigenvalues(): number;
                        getEigenvalue(index: number): util.maths.matrix.Complex64F;
                        getEigenVector(index: number): util.maths.matrix.DenseMatrix64F;
                    }
                    class WatchedDoubleStepQREigen {
                        private rand;
                        private N;
                        A: util.maths.matrix.DenseMatrix64F;
                        private u;
                        private gamma;
                        private _temp;
                        numStepsFind: Int32Array;
                        steps: number;
                        eigenvalues: util.maths.matrix.Complex64F[];
                        numEigen: number;
                        private valueSmall;
                        private temp;
                        private printHumps;
                        checkHessenberg: boolean;
                        private checkOrthogonal;
                        private checkUncountable;
                        private useStandardEq;
                        private useCareful2x2;
                        private normalize;
                        lastExceptional: number;
                        numExceptional: number;
                        exceptionalThreshold: number;
                        maxIterations: number;
                        createR: boolean;
                        Q: util.maths.matrix.DenseMatrix64F;
                        incrementSteps(): void;
                        setQ(Q: util.maths.matrix.DenseMatrix64F): void;
                        private addEigenvalue(v);
                        private addEigenvalue2arg(v, i);
                        setChecks(hessenberg: boolean, orthogonal: boolean, uncountable: boolean): void;
                        isZero(x1: number, x2: number): boolean;
                        setup(A: util.maths.matrix.DenseMatrix64F): void;
                        exceptionalShift(x1: number, x2: number): void;
                        implicitDoubleStep(x1: number, x2: number): void;
                        performImplicitDoubleStep(x1: number, x2: number, real: number, img: number): void;
                        private performImplicitDoubleStep5arg(x1, x2, b11, b21, b31);
                        performImplicitSingleStep(x1: number, x2: number, eigenvalue: number): void;
                        createBulgeSingleStep(x1: number, eigenvalue: number): boolean;
                        bulgeDoubleStepQn(i: number): boolean;
                        bulgeDoubleStepQn6arg(i: number, a11: number, a21: number, a31: number, threshold: number, set: boolean): boolean;
                        bulgeSingleStepQn(i: number): boolean;
                        bulgeSingleStepQn5arg(i: number, a11: number, a21: number, threshold: number, set: boolean): boolean;
                        eigen2by2_scale(a11: number, a12: number, a21: number, a22: number): void;
                        getNumberOfEigenvalues(): number;
                        getEigenvalues(): util.maths.matrix.Complex64F[];
                        addComputedEigen2x2(x1: number, x2: number): void;
                        isReal2x2(x1: number, x2: number): boolean;
                        addEigenAt(x1: number): void;
                        printSteps(): void;
                    }
                    class WatchedDoubleStepQREigenvalue {
                        implicitQR: util.maths.matrix.solvers.decomposition.WatchedDoubleStepQREigen;
                        splits: Int32Array;
                        numSplits: number;
                        x1: number;
                        x2: number;
                        constructor();
                        setup(A: util.maths.matrix.DenseMatrix64F): void;
                        process(origA: util.maths.matrix.DenseMatrix64F): boolean;
                        private moveToNextSplit();
                        private performIteration();
                        getNumberOfEigenvalues(): number;
                        getEigenvalues(): util.maths.matrix.Complex64F[];
                        getImplicitQR(): util.maths.matrix.solvers.decomposition.WatchedDoubleStepQREigen;
                    }
                    class WatchedDoubleStepQREigenvector {
                        implicit: util.maths.matrix.solvers.decomposition.WatchedDoubleStepQREigen;
                        Q: util.maths.matrix.DenseMatrix64F;
                        eigenvectors: util.maths.matrix.DenseMatrix64F[];
                        eigenvectorTemp: util.maths.matrix.DenseMatrix64F;
                        solver: util.maths.matrix.solvers.LinearSolverLu_D64;
                        origEigenvalues: util.maths.matrix.Complex64F[];
                        N: number;
                        splits: Int32Array;
                        numSplits: number;
                        x1: number;
                        x2: number;
                        indexVal: number;
                        onscript: boolean;
                        process(implicit: util.maths.matrix.solvers.decomposition.WatchedDoubleStepQREigen, A: util.maths.matrix.DenseMatrix64F, Q_h: util.maths.matrix.DenseMatrix64F): boolean;
                        extractVectors(Q_h: util.maths.matrix.DenseMatrix64F): boolean;
                        private solveEigenvectorDuplicateEigenvalue(real, first, isTriangle);
                        private solveUsingTriangle(real, index, r);
                        private solveWithLU(real, index, r);
                        findQandR(): boolean;
                        private findNextEigenvalue();
                        private checkSplitPerformImplicit();
                        private moveToNextSplit();
                        getQ(): util.maths.matrix.DenseMatrix64F;
                        getImplicit(): util.maths.matrix.solvers.decomposition.WatchedDoubleStepQREigen;
                        getEigenvectors(): util.maths.matrix.DenseMatrix64F[];
                        getEigenvalues(): util.maths.matrix.Complex64F[];
                    }
                }
            }
        }
        namespace structure {
            interface KArray1D {
                size(): number;
                get(index: number): number;
                set(index: number, value: number): number;
                add(index: number, value: number): number;
                addAll(value: number): void;
                setAll(value: number): void;
                addElement(index: number, numElem: number): void;
                clone(): util.maths.structure.KArray1D;
                data(): Float64Array;
                setData(data: Float64Array): void;
            }
            interface KArray2D {
                rows(): number;
                columns(): number;
                get(rowIndex: number, columnIndex: number): number;
                set(rowIndex: number, columnIndex: number, value: number): number;
                add(rowIndex: number, columnIndex: number, value: number): number;
                setAll(value: number): void;
                addRow(rowindex: number, numRow: number): void;
                addCol(colIndex: number, numCol: number): void;
                getAtIndex(index: number): number;
                setAtIndex(index: number, value: number): number;
                addAtIndex(index: number, value: number): number;
                clone(): util.maths.structure.KArray2D;
                data(): Float64Array;
                setData(data: Float64Array): void;
            }
            namespace blas {
                interface KBlas {
                    dgemm(transA: util.maths.structure.blas.KBlasTransposeType, transB: util.maths.structure.blas.KBlasTransposeType, m: number, n: number, k: number, alpha: number, matA: Float64Array, offsetA: number, ldA: number, matB: Float64Array, offsetB: number, ldB: number, beta: number, matC: Float64Array, offsetC: number, ldC: number): void;
                    dgetrs(transA: util.maths.structure.blas.KBlasTransposeType, dim: number, nrhs: number, matA: Float64Array, offsetA: number, ldA: number, ipiv: Int32Array, offsetIpiv: number, matB: Float64Array, offsetB: number, ldB: number, info: Int32Array): void;
                    dgetri(dim: number, matA: Float64Array, offsetA: number, ldA: number, ipiv: Int32Array, offsetIpiv: number, work: Float64Array, offsetWork: number, ldWork: number, info: Int32Array): void;
                    dgetrf(rows: number, columns: number, matA: Float64Array, offsetA: number, ldA: number, ipiv: Int32Array, offsetIpiv: number, info: Int32Array): void;
                    dorgqr(m: number, n: number, k: number, matA: Float64Array, offsetA: number, ldA: number, taw: Float64Array, offsetTaw: number, work: Float64Array, offsetWork: number, lWork: number, info: Int32Array): void;
                    dgeqrf(m: number, n: number, matA: Float64Array, offsetA: number, ldA: number, taw: Float64Array, offsetTaw: number, work: Float64Array, offsetwork: number, lWork: number, info: Int32Array): void;
                    shutdown(): void;
                }
                class KBlasDirectionType {
                    static FORWARD: KBlasDirectionType;
                    static BACKWARD: KBlasDirectionType;
                    equals(other: any): boolean;
                    static _KBlasDirectionTypeVALUES: KBlasDirectionType[];
                    static values(): KBlasDirectionType[];
                }
                class KBlasMajorType {
                    static COLUMNWISE: KBlasMajorType;
                    static ROWWISE: KBlasMajorType;
                    equals(other: any): boolean;
                    static _KBlasMajorTypeVALUES: KBlasMajorType[];
                    static values(): KBlasMajorType[];
                }
                class KBlasOrientationType {
                    static UPPER: KBlasOrientationType;
                    static LOWER: KBlasOrientationType;
                    equals(other: any): boolean;
                    static _KBlasOrientationTypeVALUES: KBlasOrientationType[];
                    static values(): KBlasOrientationType[];
                }
                class KBlasSideType {
                    static LEFT: KBlasSideType;
                    static RIGHT: KBlasSideType;
                    equals(other: any): boolean;
                    static _KBlasSideTypeVALUES: KBlasSideType[];
                    static values(): KBlasSideType[];
                }
                class KBlasTransposeType {
                    static NOTRANSPOSE: KBlasTransposeType;
                    static TRANSPOSE: KBlasTransposeType;
                    static CONJUGATE: KBlasTransposeType;
                    equals(other: any): boolean;
                    static _KBlasTransposeTypeVALUES: KBlasTransposeType[];
                    static values(): KBlasTransposeType[];
                }
                class KBlasUnitType {
                    static UNIT: KBlasUnitType;
                    static NONUNIT: KBlasUnitType;
                    equals(other: any): boolean;
                    static _KBlasUnitTypeVALUES: KBlasUnitType[];
                    static values(): KBlasUnitType[];
                }
                namespace impl {
                    class JavaBlas implements util.maths.structure.blas.KBlas {
                        dgemm(paramString1: util.maths.structure.blas.KBlasTransposeType, paramString2: util.maths.structure.blas.KBlasTransposeType, paramInt1: number, paramInt2: number, paramInt3: number, paramDouble1: number, paramArrayOfDouble1: Float64Array, paramInt4: number, paramInt5: number, paramArrayOfDouble2: Float64Array, paramInt6: number, paramInt7: number, paramDouble2: number, paramArrayOfDouble3: Float64Array, paramInt8: number, paramInt9: number): void;
                        dgetri(paramInt1: number, paramArrayOfDouble1: Float64Array, paramInt2: number, paramInt3: number, paramArrayOfInt: Int32Array, paramInt4: number, paramArrayOfDouble2: Float64Array, paramInt5: number, paramInt6: number, paramintW: Int32Array): void;
                        dgetrf(paramInt1: number, paramInt2: number, paramArrayOfDouble: Float64Array, paramInt3: number, paramInt4: number, paramArrayOfInt: Int32Array, paramInt5: number, info: Int32Array): void;
                        dgetrs(trans: util.maths.structure.blas.KBlasTransposeType, nOrder: number, nrhs: number, matA: Float64Array, offsetA: number, ldA: number, ipiv: Int32Array, offsetIpiV: number, matB: Float64Array, offsetB: number, ldB: number, info: Int32Array): void;
                        dorgqr(paramInt1: number, paramInt2: number, paramInt3: number, paramArrayOfDouble1: Float64Array, paramInt4: number, paramInt5: number, paramArrayOfDouble2: Float64Array, paramInt6: number, paramArrayOfDouble3: Float64Array, paramInt7: number, paramInt8: number, paramintW: Int32Array): void;
                        dgeqrf(paramInt1: number, paramInt2: number, paramArrayOfDouble1: Float64Array, paramInt3: number, paramInt4: number, paramArrayOfDouble2: Float64Array, paramInt5: number, paramArrayOfDouble3: Float64Array, paramInt6: number, paramInt7: number, paramintW: Int32Array): void;
                        dorg2r(paramInt1: number, paramInt2: number, paramInt3: number, paramArrayOfDouble1: Float64Array, paramInt4: number, paramInt5: number, paramArrayOfDouble2: Float64Array, paramInt6: number, paramArrayOfDouble3: Float64Array, paramInt7: number, paramintW: Int32Array): void;
                        dlarfb(paramString1: util.maths.structure.blas.KBlasSideType, paramString2: util.maths.structure.blas.KBlasTransposeType, paramString3: util.maths.structure.blas.KBlasDirectionType, paramString4: util.maths.structure.blas.KBlasMajorType, paramInt1: number, paramInt2: number, paramInt3: number, paramArrayOfDouble1: Float64Array, paramInt4: number, paramInt5: number, paramArrayOfDouble2: Float64Array, paramInt6: number, paramInt7: number, paramArrayOfDouble3: Float64Array, paramInt8: number, paramInt9: number, paramArrayOfDouble4: Float64Array, paramInt10: number, paramInt11: number): void;
                        dcopy(n: number, x: Float64Array, offsetx: number, incx: number, y: Float64Array, offsety: number, incy: number): void;
                        dlarft(paramString1: util.maths.structure.blas.KBlasDirectionType, paramString2: util.maths.structure.blas.KBlasMajorType, paramInt1: number, paramInt2: number, paramArrayOfDouble1: Float64Array, paramInt3: number, paramInt4: number, paramArrayOfDouble2: Float64Array, paramInt5: number, paramArrayOfDouble3: Float64Array, paramInt6: number, paramInt7: number): void;
                        dgeqr2(paramInt1: number, paramInt2: number, paramArrayOfDouble1: Float64Array, paramInt3: number, paramInt4: number, paramArrayOfDouble2: Float64Array, paramInt5: number, paramArrayOfDouble3: Float64Array, paramInt6: number, paramintW: Int32Array): void;
                        private dlarfg_adapter(paramInt1, paramArrayOfDouble1, paramInt2, paramArrayOfDouble2, paramInt3, paramInt4, paramArrayOfDouble3, paramInt5);
                        dlarf(paramString: util.maths.structure.blas.KBlasSideType, paramInt1: number, paramInt2: number, paramArrayOfDouble1: Float64Array, paramInt3: number, paramInt4: number, paramDouble: number, paramArrayOfDouble2: Float64Array, paramInt5: number, paramInt6: number, paramArrayOfDouble3: Float64Array, paramInt7: number): void;
                        dnrm2(paramInt1: number, paramArrayOfDouble: Float64Array, paramInt2: number, paramInt3: number): number;
                        dlapy2(paramDouble1: number, paramDouble2: number): number;
                        private dsign(paramDouble1, paramDouble2);
                        dlarfg(paramInt1: number, paramdoubleW1: Float64Array, paramArrayOfDouble: Float64Array, paramInt2: number, paramInt3: number, paramdoubleW2: Float64Array): void;
                        shutdown(): void;
                        dtrti2(paramString1: util.maths.structure.blas.KBlasOrientationType, paramString2: util.maths.structure.blas.KBlasUnitType, paramInt1: number, paramArrayOfDouble: Float64Array, paramInt2: number, paramInt3: number, paramintW: Int32Array): void;
                        private print(paramArrayOfDouble, s);
                        dtrmv(paramString1: util.maths.structure.blas.KBlasOrientationType, paramString2: util.maths.structure.blas.KBlasTransposeType, paramString3: util.maths.structure.blas.KBlasUnitType, paramInt1: number, paramArrayOfDouble1: Float64Array, paramInt2: number, paramInt3: number, paramArrayOfDouble2: Float64Array, paramInt4: number, paramInt5: number): void;
                        dtrmm(paramString1: util.maths.structure.blas.KBlasSideType, paramString2: util.maths.structure.blas.KBlasOrientationType, paramString3: util.maths.structure.blas.KBlasTransposeType, paramString4: util.maths.structure.blas.KBlasUnitType, paramInt1: number, paramInt2: number, paramDouble: number, paramArrayOfDouble1: Float64Array, paramInt3: number, paramInt4: number, paramArrayOfDouble2: Float64Array, paramInt5: number, paramInt6: number): void;
                        dtrtri(paramString1: util.maths.structure.blas.KBlasOrientationType, paramString2: util.maths.structure.blas.KBlasUnitType, paramInt1: number, paramArrayOfDouble: Float64Array, paramInt2: number, paramInt3: number, paramintW: Int32Array): void;
                        dgemv(paramString: util.maths.structure.blas.KBlasTransposeType, paramInt1: number, paramInt2: number, paramDouble1: number, paramArrayOfDouble1: Float64Array, paramInt3: number, paramInt4: number, paramArrayOfDouble2: Float64Array, paramInt5: number, paramInt6: number, paramDouble2: number, paramArrayOfDouble3: Float64Array, paramInt7: number, paramInt8: number): void;
                        private ilaenv(i, dgetrf, s, paramInt1, paramInt2, i1, i2);
                        dger(paramInt1: number, paramInt2: number, paramDouble: number, paramArrayOfDouble1: Float64Array, paramInt3: number, paramInt4: number, paramArrayOfDouble2: Float64Array, paramInt5: number, paramInt6: number, paramArrayOfDouble3: Float64Array, paramInt7: number, paramInt8: number): void;
                        idamax(paramInt1: number, paramArrayOfDouble: Float64Array, paramInt2: number, paramInt3: number): number;
                        dswap(paramInt1: number, paramArrayOfDouble1: Float64Array, paramInt2: number, paramInt3: number, paramArrayOfDouble2: Float64Array, paramInt4: number, paramInt5: number): void;
                        dscal(paramInt1: number, paramDouble: number, paramArrayOfDouble: Float64Array, paramInt2: number, paramInt3: number): void;
                        dgetf2(paramInt1: number, paramInt2: number, paramArrayOfDouble: Float64Array, paramInt3: number, paramInt4: number, paramArrayOfInt: Int32Array, paramInt5: number, info: Int32Array): void;
                        dlaswp(paramInt1: number, paramArrayOfDouble: Float64Array, paramInt2: number, paramInt3: number, paramInt4: number, paramInt5: number, paramArrayOfInt: Int32Array, paramInt6: number, paramInt7: number): void;
                        dtrsm(paramString1: util.maths.structure.blas.KBlasSideType, paramString2: util.maths.structure.blas.KBlasOrientationType, paramString3: util.maths.structure.blas.KBlasTransposeType, paramString4: util.maths.structure.blas.KBlasUnitType, paramInt1: number, paramInt2: number, paramDouble: number, paramArrayOfDouble1: Float64Array, paramInt3: number, paramInt4: number, paramArrayOfDouble2: Float64Array, paramInt5: number, paramInt6: number): void;
                        private floorDiv(x, y);
                    }
                }
            }
            namespace impl {
                class Array1D implements util.maths.structure.KArray1D {
                    private _size;
                    private _offset;
                    private _segmentIndex;
                    private _segment;
                    private _metaClass;
                    constructor(p_size: number, p_offset: number, p_segmentIndex: number, p_segment: memory.chunk.KObjectChunk, p_metaClass: meta.KMetaClass);
                    size(): number;
                    get(p_index: number): number;
                    set(p_index: number, p_value: number): number;
                    add(index: number, value: number): number;
                    addAll(value: number): void;
                    setAll(value: number): void;
                    addElement(index: number, numElem: number): void;
                    clone(): util.maths.structure.KArray1D;
                    data(): Float64Array;
                    setData(data: Float64Array): void;
                }
                class Array2D implements util.maths.structure.KArray2D {
                    private _nbRows;
                    private _nbColumns;
                    private _offset;
                    private _segmentIndex;
                    private _segment;
                    private _metaClass;
                    constructor(p_nbRows: number, p_nbColumns: number, p_offset: number, p_segmentIndex: number, p_segment: memory.chunk.KObjectChunk, p_metaClass: meta.KMetaClass);
                    rows(): number;
                    columns(): number;
                    private getIndex(p_rowIndex, p_columnIndex);
                    get(p_rowIndex: number, p_columnIndex: number): number;
                    set(p_rowIndex: number, p_columnIndex: number, value: number): number;
                    add(rowIndex: number, columnIndex: number, value: number): number;
                    setAll(value: number): void;
                    addRow(rowindex: number, numRow: number): void;
                    addCol(colIndex: number, numCol: number): void;
                    clone(): util.maths.structure.KArray2D;
                    data(): Float64Array;
                    setData(p_data: Float64Array): void;
                    getAtIndex(index: number): number;
                    setAtIndex(index: number, value: number): number;
                    addAtIndex(index: number, value: number): number;
                }
                class NativeArray2D implements util.maths.structure.KArray2D {
                    private _nbRows;
                    private _nbColumns;
                    private _back;
                    constructor(p_nbRows: number, p_nbColumns: number);
                    private getIndex(p_rowIndex, p_columnIndex);
                    rows(): number;
                    columns(): number;
                    get(p_rowIndex: number, p_columnIndex: number): number;
                    set(p_rowIndex: number, p_columnIndex: number, value: number): number;
                    add(rowIndex: number, columnIndex: number, value: number): number;
                    setAll(value: number): void;
                    addRow(rowindex: number, numRow: number): void;
                    addCol(colIndex: number, numCol: number): void;
                    clone(): util.maths.structure.KArray2D;
                    data(): Float64Array;
                    setData(data: Float64Array): void;
                    getAtIndex(index: number): number;
                    setAtIndex(index: number, value: number): number;
                    addAtIndex(index: number, value: number): number;
                }
            }
            namespace matrix {
                class MatrixOperations {
                    static BLOCK_WIDTH: number;
                    static TRANSPOSE_SWITCH: number;
                    static leadingDimension(matA: util.maths.structure.KArray2D): number;
                    static multiply(matA: util.maths.structure.KArray2D, matB: util.maths.structure.KArray2D, blas: util.maths.structure.blas.KBlas): util.maths.structure.KArray2D;
                    static multiplyTransposeAlpha(transA: util.maths.structure.blas.KBlasTransposeType, transB: util.maths.structure.blas.KBlasTransposeType, matA: util.maths.structure.KArray2D, matB: util.maths.structure.KArray2D, alpha: number, blas: util.maths.structure.blas.KBlas): util.maths.structure.KArray2D;
                    static multiplyAlphaBetaResult(alpha: number, matA: util.maths.structure.KArray2D, matB: util.maths.structure.KArray2D, beta: number, matC: util.maths.structure.KArray2D, blas: util.maths.structure.blas.KBlas): void;
                    static multiplyTransposeAlphaBetaResult(transA: util.maths.structure.blas.KBlasTransposeType, transB: util.maths.structure.blas.KBlasTransposeType, alpha: number, matA: util.maths.structure.KArray2D, matB: util.maths.structure.KArray2D, beta: number, matC: util.maths.structure.KArray2D, blas: util.maths.structure.blas.KBlas): void;
                    static testDimensionsABC(transA: util.maths.structure.blas.KBlasTransposeType, transB: util.maths.structure.blas.KBlasTransposeType, matA: util.maths.structure.KArray2D, matB: util.maths.structure.KArray2D, matC: util.maths.structure.KArray2D): boolean;
                    static testDimensionsAB(transA: util.maths.structure.blas.KBlasTransposeType, transB: util.maths.structure.blas.KBlasTransposeType, matA: util.maths.structure.KArray2D, matB: util.maths.structure.KArray2D): boolean;
                    static initMatrice(matA: util.maths.structure.KArray2D, random: boolean): void;
                    static random(rows: number, columns: number): util.maths.structure.KArray2D;
                    static invert(mat: util.maths.structure.KArray2D, blas: util.maths.structure.blas.KBlas): util.maths.structure.KArray2D;
                    static invertInPlace(mat: util.maths.structure.KArray2D, blas: util.maths.structure.blas.KBlas): boolean;
                    static scale(alpha: number, matA: util.maths.structure.KArray2D): void;
                    static transpose(matA: util.maths.structure.KArray2D): util.maths.structure.KArray2D;
                    private static transposeSquare(matA, result);
                    private static transposeStandard(matA, result);
                    private static transposeBlock(matA, result);
                    static createIdentity(width: number): util.maths.structure.KArray2D;
                    static solve(matA: util.maths.structure.KArray2D, matB: util.maths.structure.KArray2D, workInPlace: boolean, transB: util.maths.structure.blas.KBlasTransposeType, blas: util.maths.structure.blas.KBlas): util.maths.structure.KArray2D;
                    static compareMatrix(matA: util.maths.structure.KArray2D, matB: util.maths.structure.KArray2D): number;
                }
                namespace solver {
                    class LU {
                        private LU;
                        private piv;
                        private singular;
                        getLU(): util.maths.structure.KArray2D;
                        constructor(m: number, n: number);
                        static factorize(A: util.maths.structure.KArray2D, blas: util.maths.structure.blas.KBlas): util.maths.structure.matrix.solver.LU;
                        factor(A: util.maths.structure.KArray2D, blas: util.maths.structure.blas.KBlas): util.maths.structure.matrix.solver.LU;
                        getLower(): util.maths.structure.KArray2D;
                        getUpper(): util.maths.structure.KArray2D;
                        getPivots(): Int32Array;
                        isSingular(): boolean;
                        solve(B: util.maths.structure.KArray2D, blas: util.maths.structure.blas.KBlas): util.maths.structure.KArray2D;
                        transSolve(B: util.maths.structure.KArray2D, trans: util.maths.structure.blas.KBlasTransposeType, blas: util.maths.structure.blas.KBlas): util.maths.structure.KArray2D;
                        invert(A: util.maths.structure.KArray2D, blas: util.maths.structure.blas.KBlas): boolean;
                    }
                    class QR {
                        private Q;
                        private R;
                        m: number;
                        n: number;
                        k: number;
                        work: Float64Array;
                        workGen: Float64Array;
                        tau: Float64Array;
                        constructor(rows: number, columns: number);
                        static factorize(A: util.maths.structure.KArray2D, workInPlace: boolean, blas: util.maths.structure.blas.KBlas): util.maths.structure.matrix.solver.QR;
                        factor(matA: util.maths.structure.KArray2D, workInPlace: boolean, blas: util.maths.structure.blas.KBlas): util.maths.structure.matrix.solver.QR;
                        getR(): util.maths.structure.KArray2D;
                        getQ(): util.maths.structure.KArray2D;
                    }
                }
            }
        }
    }
}
